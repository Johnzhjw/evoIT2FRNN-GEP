#include "MOP_HDSN_URBAN.h"
#include "stdio.h"
#include "string.h"
#include "stdlib.h"
#include "math.h"
#include "time.h"

#ifdef TII_SC_URBAN1
#define lon 37 //URBAN1
#define wid 54 //URBAN1
#define height_max 9 //URBAN1

// position of the sink node
#define SINK_X (lon/2)
#define SINK_Y (wid-1)
#define SINK_Z (0.000)

#else
#define lon 40 //URBAN2
#define wid 46 //URBAN2
#define height_max (9.999e+01) //URBAN2

// position of the sink node
#define SINK_X (lon/2)
#define SINK_Y (wid-1)
#define SINK_Z (4.808e+00)

#endif

#define max_obst 128

#define min_mirror_length 2

#define direction_north 0
#define direction_east  1
#define direction_south 2
#define direction_west  3

#define bound_north 0
#define bound_east  1
#define bound_south 2
#define bound_west  3

#define angle_ind_min 0
#define angle_ind_max 1

#define INF_DOUBLE_HDSN_URBAN (9.9E299)

#define resolution 5 //5.0m
#define X 0
#define Y 1
#define Z 2
#define PAN  2
#define TILT 3
#define PI 3.14
#define pi 3.1415926
#define r_min (45.0*2.0/3.0/resolution) // 45m//6 9
#define r_max (72.0*2.0/3.0/resolution) // 72m//9.6 14.4
#define r_ratio_mid 1.5
#define r_ratio_upp 2.0
#define vi1 0.5
#define vi2 0.5
#define omega1 3.6
#define omega2 3.6
#define P (lon*wid)//????¦Ì?¦Ì???¨ºy
#define ga (-0.5)
#define oq_beta 0.9
#define angle_min (pi/4*2/3/2)// (pi/8)
#define angle_max (pi/3*2/3/2)// (pi/6)
#define angle_ratio_mid 1.5
#define angle_ratio_upp 2.0
#define lamda1 0.5
#define lamda2 0.5
#define mu1 3.6
#define mu2 3.6
#define delta1_min 0.5
#define delta1_max 1.5
#define delta2_min 0.5
#define delta2_max 1.5
#define penalty 1e6
#define sqrtPI  (sqrt(pi))
#define WHratio (1.333333)

#define TH_NNEI 2

#define ini_db 100.0

#define th_PL 90
#define th_PL_relay (2*th_PL)
#define n_PL 3.0
#define a_PL 0.9
static double l_PL[2] = { 23, 23 }; // terrain, concrete

#ifdef TII_SC_URBAN1
//URBAN1
static double map[lon][wid] = {
	{ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 0, 0, 0, 0, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ 0, 0, 0, 0, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 0, 0, 0, 0, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 0, 0, 0 },
	{ 0, 0, 0, 0, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 0, 0, 0, 0, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 0, 0, 0 },
	{ 0, 0, 0, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 0, 0, 0 },
	{ 0, 0, 0, 9, 9, 0, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 0, 9, 9, 0, 0, 0 },
	{ 0, 0, 0, 9, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 9, 9, 9, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 9, 9, 9, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 9, 9, 0, 0, 0 },
	{ 0, 0, 0, 9, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 9, 9, 0, 0, 0 },
	{ 0, 0, 0, 9, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 9, 9, 0, 0, 0 },
	{ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 9, 9, 9, 9, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 9, 9, 9, 9, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ 0, 0, 0, 0, 0, 0, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 0, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 0, 0, 0, 0, 0, 0 },
	{ 0, 0, 0, 0, 0, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 0, 0, 0, 0, 0 },
	{ 0, 0, 0, 0, 0, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 0, 0, 0, 0, 0 },
	{ 0, 0, 0, 0, 0, 0, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 0, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 0, 0, 0, 0, 0, 0 },
	{ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 9, 9, 9, 9, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 9, 9, 9, 9, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ 0, 0, 0, 9, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 9, 9, 9, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 9, 9, 0, 0, 0 },
	{ 0, 0, 0, 9, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 9, 9, 9, 9, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 9, 9, 9, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 9, 9, 0, 0, 0 },
	{ 0, 0, 0, 9, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 9, 9, 9, 9, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 9, 9, 9, 9, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 9, 9, 0, 0, 0 },
	{ 0, 0, 0, 9, 9, 0, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 0, 9, 9, 0, 0, 0 },
	{ 0, 0, 0, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 0, 0, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 0, 0, 0 },
	{ 0, 0, 0, 0, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 0, 0, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 0, 0, 0 },
	{ 0, 0, 0, 0, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 0, 0, 0 },
	{ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }
};
#else
//URBAN2
static double map[lon][wid] = {
	{ 1.515e+01, 1.491e+01, 9.999e+01, 9.999e+01, 9.999e+01, 9.999e+01, 9.999e+01, 1.173e+01, 1.068e+01, 1.068e+01, 1.068e+01, 9.999e+01, 9.999e+01, 9.999e+01, 9.999e+01, 9.999e+01, 5.915e+00, 5.758e+00, 5.696e+00, 9.999e+01, 9.999e+01, 9.999e+01, 9.999e+01, 9.999e+01, 4.852e+00, 4.462e+00, 4.196e+00, 3.977e+00, 3.680e+00, 3.508e+00, 3.258e+00, 2.743e+00, 2.508e+00, 2.368e+00, 2.368e+00, 2.368e+00, 2.368e+00, 2.368e+00, 2.430e+00, 2.430e+00, 2.508e+00, 2.618e+00, 2.618e+00, 2.743e+00, 3.555e+00, 4.399e+00 },
	{ 1.463e+01, 1.463e+01, 9.999e+01, 9.999e+01, 9.999e+01, 9.999e+01, 9.999e+01, 1.164e+01, 1.067e+01, 1.072e+01, 1.072e+01, 9.999e+01, 9.999e+01, 9.999e+01, 9.999e+01, 9.999e+01, 5.789e+00, 5.711e+00, 5.711e+00, 9.999e+01, 9.999e+01, 9.999e+01, 9.999e+01, 9.999e+01, 4.727e+00, 4.242e+00, 3.946e+00, 3.680e+00, 3.414e+00, 3.211e+00, 2.883e+00, 2.321e+00, 9.999e+01, 9.999e+01, 9.999e+01, 9.999e+01, 9.999e+01, 9.999e+01, 9.999e+01, 9.999e+01, 9.999e+01, 9.999e+01, 9.999e+01, 2.086e+00, 2.625e+00, 4.110e+00 },
	{ 1.478e+01, 1.456e+01, 9.999e+01, 9.999e+01, 9.999e+01, 9.999e+01, 9.999e+01, 1.185e+01, 1.091e+01, 1.066e+01, 1.160e+01, 9.999e+01, 9.999e+01, 9.999e+01, 9.999e+01, 9.999e+01, 5.882e+00, 5.616e+00, 5.661e+00, 9.999e+01, 9.999e+01, 9.999e+01, 9.999e+01, 9.999e+01, 4.531e+00, 4.013e+00, 3.646e+00, 3.405e+00, 3.099e+00, 2.884e+00, 2.596e+00, 2.215e+00, 9.999e+01, 9.999e+01, 9.999e+01, 9.999e+01, 9.999e+01, 9.999e+01, 9.999e+01, 9.999e+01, 9.999e+01, 9.999e+01, 9.999e+01, 2.079e+00, 2.618e+00, 4.023e+00 },
	{ 1.479e+01, 1.473e+01, 1.446e+01, 1.458e+01, 1.401e+01, 1.348e+01, 1.299e+01, 1.235e+01, 1.150e+01, 1.093e+01, 1.064e+01, 1.041e+01, 1.019e+01, 9.783e+00, 9.202e+00, 7.796e+00, 6.442e+00, 6.005e+00, 5.726e+00, 5.697e+00, 5.643e+00, 5.617e+00, 5.479e+00, 5.112e+00, 4.426e+00, 3.767e+00, 3.427e+00, 3.084e+00, 2.818e+00, 2.540e+00, 2.295e+00, 2.058e+00, 9.999e+01, 9.999e+01, 9.999e+01, 9.999e+01, 9.999e+01, 9.999e+01, 9.999e+01, 9.999e+01, 9.999e+01, 9.999e+01, 9.999e+01, 2.064e+00, 2.596e+00, 3.944e+00 },
	{ 1.435e+01, 1.421e+01, 1.365e+01, 1.325e+01, 1.294e+01, 1.261e+01, 1.223e+01, 1.205e+01, 1.168e+01, 1.080e+01, 9.866e+00, 9.424e+00, 9.016e+00, 8.384e+00, 7.988e+00, 7.535e+00, 7.054e+00, 6.341e+00, 5.687e+00, 5.469e+00, 5.318e+00, 5.106e+00, 4.855e+00, 4.381e+00, 3.829e+00, 3.280e+00, 2.946e+00, 2.684e+00, 2.446e+00, 2.190e+00, 1.976e+00, 1.966e+00, 9.999e+01, 9.999e+01, 9.999e+01, 9.999e+01, 9.999e+01, 9.999e+01, 9.999e+01, 9.999e+01, 9.999e+01, 9.999e+01, 9.999e+01, 2.075e+00, 2.551e+00, 3.893e+00 },
	{ 1.386e+01, 1.324e+01, 1.147e+01, 1.083e+01, 1.077e+01, 1.071e+01, 1.065e+01, 1.095e+01, 1.111e+01, 9.211e+00, 8.055e+00, 7.958e+00, 7.886e+00, 7.776e+00, 7.685e+00, 7.367e+00, 6.866e+00, 5.669e+00, 4.833e+00, 4.728e+00, 4.669e+00, 4.618e+00, 4.495e+00, 4.099e+00, 3.258e+00, 2.486e+00, 2.270e+00, 2.219e+00, 2.159e+00, 2.002e+00, 1.703e+00, 1.887e+00, 9.999e+01, 9.999e+01, 9.999e+01, 9.999e+01, 9.999e+01, 9.999e+01, 9.999e+01, 9.999e+01, 9.999e+01, 9.999e+01, 9.999e+01, 2.057e+00, 2.563e+00, 3.813e+00 },
	{ 1.330e+01, 1.262e+01, 1.089e+01, 1.029e+01, 1.027e+01, 1.028e+01, 1.027e+01, 1.074e+01, 1.065e+01, 8.629e+00, 7.620e+00, 7.619e+00, 7.635e+00, 7.588e+00, 7.571e+00, 7.230e+00, 6.703e+00, 5.368e+00, 4.533e+00, 4.521e+00, 4.529e+00, 4.511e+00, 4.423e+00, 3.990e+00, 3.050e+00, 2.280e+00, 2.118e+00, 2.118e+00, 2.133e+00, 1.867e+00, 1.453e+00, 1.841e+00, 9.999e+01, 9.999e+01, 9.999e+01, 9.999e+01, 9.999e+01, 9.999e+01, 9.999e+01, 9.999e+01, 9.999e+01, 9.999e+01, 9.999e+01, 2.058e+00, 2.517e+00, 3.753e+00 },
	{ 1.272e+01, 1.219e+01, 1.073e+01, 9.999e+01, 9.999e+01, 9.999e+01, 1.027e+01, 1.051e+01, 1.032e+01, 8.531e+00, 9.999e+01, 9.999e+01, 9.999e+01, 7.614e+00, 7.508e+00, 7.078e+00, 6.571e+00, 5.325e+00, 4.538e+00, 9.999e+01, 9.999e+01, 9.999e+01, 4.391e+00, 3.851e+00, 2.942e+00, 9.999e+01, 9.999e+01, 9.999e+01, 2.134e+00, 1.770e+00, 1.253e+00, 1.762e+00, 9.999e+01, 9.999e+01, 9.999e+01, 9.999e+01, 9.999e+01, 9.999e+01, 9.999e+01, 9.999e+01, 9.999e+01, 9.999e+01, 9.999e+01, 2.048e+00, 2.505e+00, 3.722e+00 },
	{ 1.201e+01, 1.168e+01, 1.064e+01, 9.999e+01, 9.999e+01, 9.999e+01, 1.040e+01, 1.027e+01, 9.858e+00, 8.332e+00, 9.999e+01, 9.999e+01, 9.999e+01, 7.622e+00, 7.441e+00, 6.879e+00, 6.389e+00, 5.261e+00, 4.554e+00, 9.999e+01, 9.999e+01, 9.999e+01, 4.386e+00, 3.748e+00, 2.814e+00, 9.999e+01, 9.999e+01, 9.999e+01, 2.124e+00, 1.642e+00, 1.115e+00, 1.669e+00, 9.999e+01, 9.999e+01, 9.999e+01, 9.999e+01, 9.999e+01, 9.999e+01, 9.999e+01, 9.999e+01, 9.999e+01, 9.999e+01, 9.999e+01, 2.067e+00, 2.488e+00, 3.705e+00 },
	{ 1.130e+01, 1.115e+01, 1.051e+01, 9.999e+01, 9.999e+01, 9.999e+01, 1.029e+01, 1.010e+01, 9.380e+00, 8.162e+00, 9.999e+01, 9.999e+01, 9.999e+01, 7.630e+00, 7.399e+00, 6.706e+00, 6.237e+00, 5.183e+00, 4.518e+00, 9.999e+01, 9.999e+01, 9.999e+01, 4.372e+00, 3.632e+00, 2.709e+00, 9.999e+01, 9.999e+01, 9.999e+01, 2.115e+00, 1.559e+00, 9.297e-01, 1.637e+00, 9.999e+01, 9.999e+01, 9.999e+01, 9.999e+01, 9.999e+01, 9.999e+01, 9.999e+01, 9.999e+01, 9.999e+01, 9.999e+01, 9.999e+01, 2.075e+00, 2.499e+00, 3.684e+00 },
	{ 1.068e+01, 1.063e+01, 1.038e+01, 9.999e+01, 9.999e+01, 9.999e+01, 1.033e+01, 9.872e+00, 8.880e+00, 7.976e+00, 9.999e+01, 9.999e+01, 9.999e+01, 7.629e+00, 7.333e+00, 6.555e+00, 6.062e+00, 5.153e+00, 4.537e+00, 9.999e+01, 9.999e+01, 9.999e+01, 4.349e+00, 3.578e+00, 2.637e+00, 9.999e+01, 9.999e+01, 9.999e+01, 2.119e+00, 1.530e+00, 8.825e-01, 1.615e+00, 9.999e+01, 9.999e+01, 9.999e+01, 9.999e+01, 9.999e+01, 9.999e+01, 9.999e+01, 9.999e+01, 9.999e+01, 9.999e+01, 9.999e+01, 2.072e+00, 2.494e+00, 3.687e+00 },
	{ 9.918e+00, 1.002e+01, 1.022e+01, 9.999e+01, 9.999e+01, 9.999e+01, 1.028e+01, 9.643e+00, 8.440e+00, 7.810e+00, 9.999e+01, 9.999e+01, 9.999e+01, 7.630e+00, 7.283e+00, 6.430e+00, 5.976e+00, 5.083e+00, 4.506e+00, 9.999e+01, 9.999e+01, 9.999e+01, 4.320e+00, 3.514e+00, 2.606e+00, 9.999e+01, 9.999e+01, 9.999e+01, 2.103e+00, 1.494e+00, 7.977e-01, 1.525e+00, 1.919e+00, 1.912e+00, 1.883e+00, 1.933e+00, 1.954e+00, 1.954e+00, 1.954e+00, 2.032e+00, 2.052e+00, 2.103e+00, 2.140e+00, 2.174e+00, 2.552e+00, 3.753e+00 },
	{ 9.250e+00, 9.407e+00, 1.003e+01, 9.999e+01, 9.999e+01, 9.999e+01, 1.029e+01, 9.238e+00, 8.002e+00, 7.650e+00, 9.999e+01, 9.999e+01, 9.999e+01, 7.623e+00, 7.225e+00, 6.300e+00, 5.890e+00, 5.063e+00, 4.510e+00, 9.999e+01, 9.999e+01, 9.999e+01, 4.325e+00, 3.505e+00, 2.556e+00, 9.999e+01, 9.999e+01, 9.999e+01, 2.119e+00, 1.432e+00, 7.076e-01, 7.076e-01, 9.242e-01, 9.242e-01, 9.242e-01, 1.038e+00, 1.231e+00, 1.344e+00, 1.522e+00, 1.816e+00, 2.038e+00, 2.322e+00, 2.611e+00, 2.906e+00, 3.402e+00, 4.066e+00 },
	{ 8.623e+00, 9.065e+00, 9.946e+00, 9.999e+01, 9.999e+01, 9.999e+01, 1.033e+01, 9.216e+00, 7.491e+00, 7.491e+00, 9.999e+01, 9.999e+01, 9.999e+01, 7.620e+00, 7.213e+00, 6.201e+00, 5.842e+00, 5.020e+00, 4.541e+00, 9.999e+01, 9.999e+01, 9.999e+01, 4.313e+00, 3.497e+00, 2.577e+00, 9.999e+01, 9.999e+01, 9.999e+01, 2.080e+00, 1.413e+00, 5.773e-01, 3.893e-01, 3.100e-01, 2.765e-01, 3.551e-01, 5.158e-01, 6.791e-01, 9.616e-01, 1.280e+00, 1.610e+00, 2.000e+00, 2.419e+00, 2.806e+00, 3.277e+00, 3.782e+00, 4.204e+00 },
	{ 8.034e+00, 8.581e+00, 9.813e+00, 1.024e+01, 1.032e+01, 1.021e+01, 1.027e+01, 8.997e+00, 7.086e+00, 7.332e+00, 7.617e+00, 7.606e+00, 7.587e+00, 7.587e+00, 7.162e+00, 6.151e+00, 5.761e+00, 4.975e+00, 4.543e+00, 4.498e+00, 4.498e+00, 4.530e+00, 4.304e+00, 3.457e+00, 2.507e+00, 2.169e+00, 2.059e+00, 2.058e+00, 2.109e+00, 1.371e+00, 4.901e-01, 6.751e-01, 8.880e-01, 8.880e-01, 8.880e-01, 9.730e-01, 9.730e-01, 1.111e+00, 1.222e+00, 1.371e+00, 1.520e+00, 1.658e+00, 1.837e+00, 2.154e+00, 3.510e+00, 4.290e+00 },
	{ 7.490e+00, 7.553e+00, 8.552e+00, 8.979e+00, 8.979e+00, 9.014e+00, 8.933e+00, 8.103e+00, 6.710e+00, 6.898e+00, 7.138e+00, 7.091e+00, 7.091e+00, 7.006e+00, 6.742e+00, 5.992e+00, 5.702e+00, 5.234e+00, 4.830e+00, 4.641e+00, 4.472e+00, 4.274e+00, 4.021e+00, 3.340e+00, 2.646e+00, 2.187e+00, 1.882e+00, 1.797e+00, 1.669e+00, 1.116e+00, 5.091e-01, 8.961e-01, 1.201e+00, 1.227e+00, 1.227e+00, 1.242e+00, 1.242e+00, 1.236e+00, 1.230e+00, 1.252e+00, 1.252e+00, 1.259e+00, 1.212e+00, 1.694e+00, 3.367e+00, 4.440e+00 },
	{ 7.027e+00, 7.012e+00, 7.050e+00, 7.050e+00, 7.077e+00, 7.017e+00, 6.879e+00, 6.779e+00, 6.495e+00, 6.425e+00, 6.390e+00, 6.344e+00, 6.279e+00, 6.181e+00, 6.059e+00, 5.824e+00, 5.642e+00, 5.410e+00, 5.136e+00, 4.848e+00, 4.499e+00, 4.125e+00, 3.708e+00, 3.175e+00, 2.687e+00, 2.161e+00, 1.711e+00, 1.358e+00, 9.822e-01, 6.421e-01, 4.192e-01, 9.187e-01, 9.999e+01, 9.999e+01, 9.999e+01, 9.999e+01, 9.999e+01, 9.999e+01, 9.999e+01, 9.999e+01, 9.999e+01, 9.999e+01, 1.190e+00, 1.635e+00, 3.469e+00, 4.551e+00 },
	{ 6.694e+00, 6.791e+00, 6.972e+00, 6.994e+00, 6.983e+00, 6.962e+00, 6.931e+00, 6.872e+00, 6.625e+00, 6.512e+00, 6.610e+00, 6.559e+00, 6.498e+00, 6.440e+00, 6.259e+00, 5.781e+00, 5.606e+00, 5.385e+00, 5.172e+00, 4.883e+00, 4.550e+00, 4.091e+00, 3.603e+00, 3.107e+00, 2.629e+00, 2.082e+00, 1.660e+00, 1.229e+00, 8.225e-01, 5.195e-01, 4.287e-01, 9.223e-01, 9.999e+01, 9.999e+01, 9.999e+01, 9.999e+01, 9.999e+01, 9.999e+01, 9.999e+01, 9.999e+01, 9.999e+01, 9.999e+01, 1.290e+00, 1.651e+00, 3.502e+00, 4.598e+00 },
	{ 6.510e+00, 6.734e+00, 7.217e+00, 7.386e+00, 7.408e+00, 7.408e+00, 7.382e+00, 7.343e+00, 6.932e+00, 6.769e+00, 7.018e+00, 6.989e+00, 7.066e+00, 7.018e+00, 6.806e+00, 5.887e+00, 5.394e+00, 5.128e+00, 5.043e+00, 4.922e+00, 4.788e+00, 4.190e+00, 3.384e+00, 2.493e+00, 2.203e+00, 1.986e+00, 1.751e+00, 1.666e+00, 1.166e+00, 3.873e-01, 3.500e-01, 8.990e-01, 9.999e+01, 9.999e+01, 9.999e+01, 9.999e+01, 9.999e+01, 9.999e+01, 9.999e+01, 9.999e+01, 9.999e+01, 9.999e+01, 1.250e+00, 1.655e+00, 3.505e+00, 4.717e+00 },
	{ 6.535e+00, 6.910e+00, 7.223e+00, 9.999e+01, 9.999e+01, 9.999e+01, 9.999e+01, 7.223e+00, 6.723e+00, 6.843e+00, 9.999e+01, 9.999e+01, 9.999e+01, 9.999e+01, 6.823e+00, 5.952e+00, 5.301e+00, 9.999e+01, 9.999e+01, 9.999e+01, 9.999e+01, 4.324e+00, 3.294e+00, 2.191e+00, 9.999e+01, 9.999e+01, 9.999e+01, 9.999e+01, 1.371e+00, 3.668e-01, 3.009e-01, 8.573e-01, 9.999e+01, 9.999e+01, 9.999e+01, 9.999e+01, 9.999e+01, 9.999e+01, 9.999e+01, 9.999e+01, 9.999e+01, 9.999e+01, 1.211e+00, 1.713e+00, 3.572e+00, 4.768e+00 },
	{ 6.718e+00, 6.876e+00, 7.253e+00, 9.999e+01, 9.999e+01, 9.999e+01, 9.999e+01, 7.451e+00, 7.163e+00, 6.956e+00, 9.999e+01, 9.999e+01, 9.999e+01, 9.999e+01, 6.793e+00, 6.024e+00, 5.320e+00, 9.999e+01, 9.999e+01, 9.999e+01, 9.999e+01, 4.273e+00, 3.116e+00, 2.188e+00, 9.999e+01, 9.999e+01, 9.999e+01, 9.999e+01, 1.332e+00, 3.893e-01, 2.359e-01, 8.548e-01, 9.999e+01, 9.999e+01, 9.999e+01, 9.999e+01, 9.999e+01, 9.999e+01, 9.999e+01, 9.999e+01, 9.999e+01, 9.999e+01, 1.211e+00, 1.734e+00, 3.625e+00, 4.808e+00 },
	{ 6.893e+00, 7.074e+00, 7.340e+00, 9.999e+01, 9.999e+01, 9.999e+01, 9.999e+01, 7.425e+00, 7.271e+00, 7.057e+00, 9.999e+01, 9.999e+01, 9.999e+01, 9.999e+01, 6.859e+00, 6.170e+00, 5.365e+00, 9.999e+01, 9.999e+01, 9.999e+01, 9.999e+01, 4.202e+00, 3.128e+00, 2.143e+00, 9.999e+01, 9.999e+01, 9.999e+01, 9.999e+01, 1.322e+00, 2.677e-01, 1.966e-01, 8.307e-01, 9.999e+01, 9.999e+01, 9.999e+01, 9.999e+01, 9.999e+01, 9.999e+01, 9.999e+01, 9.999e+01, 9.999e+01, 9.999e+01, 1.211e+00, 1.734e+00, 3.559e+00, 4.770e+00 },
	{ 7.097e+00, 7.313e+00, 7.394e+00, 9.999e+01, 9.999e+01, 9.999e+01, 9.999e+01, 7.377e+00, 7.377e+00, 7.160e+00, 9.999e+01, 9.999e+01, 9.999e+01, 9.999e+01, 6.894e+00, 6.302e+00, 5.467e+00, 9.999e+01, 9.999e+01, 9.999e+01, 9.999e+01, 4.147e+00, 2.999e+00, 2.152e+00, 9.999e+01, 9.999e+01, 9.999e+01, 9.999e+01, 1.289e+00, 2.964e-01, 2.016e-01, 8.467e-01, 9.999e+01, 9.999e+01, 9.999e+01, 9.999e+01, 9.999e+01, 9.999e+01, 9.999e+01, 9.999e+01, 9.999e+01, 9.999e+01, 1.211e+00, 1.732e+00, 3.596e+00, 4.787e+00 },
	{ 7.434e+00, 7.489e+00, 7.452e+00, 9.999e+01, 9.999e+01, 9.999e+01, 9.999e+01, 7.377e+00, 7.517e+00, 7.243e+00, 9.999e+01, 9.999e+01, 9.999e+01, 9.999e+01, 6.894e+00, 6.485e+00, 5.535e+00, 9.999e+01, 9.999e+01, 9.999e+01, 9.999e+01, 4.094e+00, 2.932e+00, 2.119e+00, 9.999e+01, 9.999e+01, 9.999e+01, 9.999e+01, 1.288e+00, 2.390e-01, 2.087e-01, 8.576e-01, 9.999e+01, 9.999e+01, 9.999e+01, 9.999e+01, 9.999e+01, 9.999e+01, 9.999e+01, 9.999e+01, 9.999e+01, 9.999e+01, 1.253e+00, 1.671e+00, 3.559e+00, 4.670e+00 },
	{ 7.737e+00, 7.737e+00, 7.523e+00, 9.999e+01, 9.999e+01, 9.999e+01, 9.999e+01, 7.408e+00, 7.646e+00, 7.370e+00, 9.999e+01, 9.999e+01, 9.999e+01, 9.999e+01, 7.019e+00, 6.674e+00, 5.634e+00, 9.999e+01, 9.999e+01, 9.999e+01, 9.999e+01, 4.051e+00, 2.873e+00, 2.079e+00, 9.999e+01, 9.999e+01, 9.999e+01, 9.999e+01, 1.256e+00, 2.093e-01, 1.747e-01, 8.272e-01, 1.206e+00, 1.206e+00, 1.206e+00, 1.206e+00, 1.206e+00, 1.206e+00, 1.206e+00, 1.206e+00, 1.206e+00, 1.206e+00, 1.206e+00, 1.656e+00, 3.469e+00, 4.627e+00 },
	{ 8.048e+00, 8.048e+00, 7.652e+00, 9.999e+01, 9.999e+01, 9.999e+01, 9.999e+01, 7.413e+00, 7.808e+00, 7.484e+00, 9.999e+01, 9.999e+01, 9.999e+01, 9.999e+01, 7.086e+00, 6.846e+00, 5.769e+00, 9.999e+01, 9.999e+01, 9.999e+01, 9.999e+01, 4.014e+00, 2.827e+00, 2.096e+00, 9.999e+01, 9.999e+01, 9.999e+01, 9.999e+01, 1.261e+00, 1.694e-01, 1.133e-01, 8.066e-01, 1.109e+00, 1.109e+00, 1.146e+00, 1.146e+00, 1.178e+00, 1.252e+00, 1.230e+00, 1.230e+00, 1.230e+00, 1.355e+00, 1.395e+00, 1.670e+00, 3.439e+00, 4.556e+00 },
	{ 8.539e+00, 8.816e+00, 8.445e+00, 7.864e+00, 7.756e+00, 7.795e+00, 7.747e+00, 7.720e+00, 8.165e+00, 7.874e+00, 7.367e+00, 7.325e+00, 7.287e+00, 7.237e+00, 7.233e+00, 7.110e+00, 6.202e+00, 5.287e+00, 5.072e+00, 4.930e+00, 4.754e+00, 3.983e+00, 2.895e+00, 2.141e+00, 1.934e+00, 1.817e+00, 1.722e+00, 1.668e+00, 1.137e+00, 1.201e-01, 0.000e+00, 3.479e-01, 5.708e-01, 5.149e-01, 6.379e-01, 6.379e-01, 9.079e-01, 1.181e+00, 1.341e+00, 1.513e+00, 1.717e+00, 2.019e+00, 2.287e+00, 2.816e+00, 3.698e+00, 4.502e+00 },
	{ 9.331e+00, 9.730e+00, 9.712e+00, 9.478e+00, 9.547e+00, 9.428e+00, 9.465e+00, 9.355e+00, 9.256e+00, 9.131e+00, 8.641e+00, 8.309e+00, 8.128e+00, 7.936e+00, 7.628e+00, 7.131e+00, 6.773e+00, 6.275e+00, 5.980e+00, 5.705e+00, 4.781e+00, 3.760e+00, 3.079e+00, 2.474e+00, 2.018e+00, 1.686e+00, 1.361e+00, 1.052e+00, 4.984e-01, 1.290e-01, 5.990e-02, 8.812e-01, 1.372e+00, 1.372e+00, 1.389e+00, 1.447e+00, 1.499e+00, 1.599e+00, 1.702e+00, 1.732e+00, 1.784e+00, 1.892e+00, 2.152e+00, 3.200e+00, 3.985e+00, 4.423e+00 },
	{ 9.657e+00, 9.949e+00, 9.846e+00, 9.742e+00, 9.999e+01, 9.999e+01, 9.999e+01, 9.999e+01, 9.999e+01, 9.634e+00, 9.325e+00, 8.908e+00, 8.642e+00, 8.382e+00, 7.578e+00, 6.820e+00, 6.725e+00, 6.676e+00, 6.676e+00, 6.429e+00, 5.263e+00, 3.845e+00, 3.062e+00, 2.525e+00, 2.227e+00, 2.037e+00, 1.911e+00, 1.714e+00, 9.100e-01, 1.288e-01, 1.996e-01, 1.210e+00, 9.999e+01, 9.999e+01, 9.999e+01, 9.999e+01, 9.999e+01, 9.999e+01, 9.999e+01, 9.999e+01, 9.999e+01, 9.999e+01, 2.006e+00, 3.045e+00, 3.942e+00, 4.418e+00 },
	{ 9.719e+00, 9.930e+00, 9.930e+00, 9.749e+00, 9.999e+01, 9.999e+01, 9.999e+01, 9.999e+01, 9.999e+01, 9.675e+00, 9.514e+00, 9.178e+00, 8.876e+00, 8.561e+00, 7.695e+00, 6.861e+00, 9.999e+01, 9.999e+01, 9.999e+01, 6.598e+00, 5.445e+00, 3.972e+00, 3.101e+00, 2.425e+00, 9.999e+01, 9.999e+01, 9.999e+01, 9.999e+01, 1.524e+00, 2.771e-01, 2.771e-01, 1.216e+00, 9.999e+01, 9.999e+01, 9.999e+01, 9.999e+01, 9.999e+01, 9.999e+01, 9.999e+01, 9.999e+01, 9.999e+01, 9.999e+01, 2.046e+00, 3.080e+00, 3.945e+00, 4.366e+00 },
	{ 9.816e+00, 9.963e+00, 9.876e+00, 9.726e+00, 9.999e+01, 9.999e+01, 9.999e+01, 9.999e+01, 9.999e+01, 9.681e+00, 9.589e+00, 9.378e+00, 9.117e+00, 8.811e+00, 7.820e+00, 6.858e+00, 9.999e+01, 9.999e+01, 9.999e+01, 6.602e+00, 5.511e+00, 4.124e+00, 3.230e+00, 2.479e+00, 9.999e+01, 9.999e+01, 9.999e+01, 9.999e+01, 1.583e+00, 4.313e-01, 4.022e-01, 1.272e+00, 9.999e+01, 9.999e+01, 9.999e+01, 9.999e+01, 9.999e+01, 9.999e+01, 9.999e+01, 9.999e+01, 9.999e+01, 9.999e+01, 2.041e+00, 3.127e+00, 3.986e+00, 4.448e+00 },
	{ 9.843e+00, 9.933e+00, 9.898e+00, 9.742e+00, 9.999e+01, 9.999e+01, 9.999e+01, 9.999e+01, 9.999e+01, 9.720e+00, 9.750e+00, 9.516e+00, 9.294e+00, 8.927e+00, 7.866e+00, 6.887e+00, 9.999e+01, 9.999e+01, 9.999e+01, 6.623e+00, 5.663e+00, 4.299e+00, 3.365e+00, 2.510e+00, 9.999e+01, 9.999e+01, 9.999e+01, 9.999e+01, 1.672e+00, 6.227e-01, 5.021e-01, 1.301e+00, 9.999e+01, 9.999e+01, 9.999e+01, 9.999e+01, 9.999e+01, 9.999e+01, 9.999e+01, 9.999e+01, 9.999e+01, 9.999e+01, 2.057e+00, 3.157e+00, 3.999e+00, 4.432e+00 },
	{ 9.915e+00, 9.944e+00, 9.881e+00, 9.749e+00, 9.999e+01, 9.999e+01, 9.999e+01, 9.999e+01, 9.999e+01, 9.705e+00, 9.849e+00, 9.738e+00, 9.486e+00, 9.095e+00, 8.040e+00, 6.906e+00, 9.999e+01, 9.999e+01, 9.999e+01, 6.626e+00, 5.718e+00, 4.427e+00, 3.503e+00, 2.554e+00, 9.999e+01, 9.999e+01, 9.999e+01, 9.999e+01, 1.762e+00, 8.438e-01, 7.484e-01, 1.396e+00, 9.999e+01, 9.999e+01, 9.999e+01, 9.999e+01, 9.999e+01, 9.999e+01, 9.999e+01, 9.999e+01, 9.999e+01, 9.999e+01, 2.053e+00, 3.232e+00, 4.088e+00, 4.486e+00 },
	{ 9.944e+00, 9.966e+00, 9.899e+00, 9.743e+00, 9.999e+01, 9.999e+01, 9.999e+01, 9.999e+01, 9.999e+01, 9.655e+00, 9.933e+00, 9.872e+00, 9.579e+00, 9.204e+00, 8.105e+00, 6.926e+00, 9.999e+01, 9.999e+01, 9.999e+01, 6.632e+00, 5.868e+00, 4.670e+00, 3.640e+00, 2.604e+00, 9.999e+01, 9.999e+01, 9.999e+01, 9.999e+01, 1.915e+00, 1.175e+00, 1.023e+00, 1.486e+00, 9.999e+01, 9.999e+01, 9.999e+01, 9.999e+01, 9.999e+01, 9.999e+01, 9.999e+01, 9.999e+01, 9.999e+01, 9.999e+01, 2.077e+00, 3.338e+00, 4.148e+00, 4.547e+00 },
	{ 9.953e+00, 9.943e+00, 9.890e+00, 9.742e+00, 9.999e+01, 9.999e+01, 9.999e+01, 9.999e+01, 9.999e+01, 9.878e+00, 9.960e+00, 9.916e+00, 9.597e+00, 9.222e+00, 8.138e+00, 6.925e+00, 9.999e+01, 9.999e+01, 9.999e+01, 6.643e+00, 5.907e+00, 4.807e+00, 3.799e+00, 2.637e+00, 9.999e+01, 9.999e+01, 9.999e+01, 9.999e+01, 2.007e+00, 1.512e+00, 1.282e+00, 1.659e+00, 9.999e+01, 9.999e+01, 9.999e+01, 9.999e+01, 9.999e+01, 9.999e+01, 9.999e+01, 9.999e+01, 9.999e+01, 9.999e+01, 2.107e+00, 3.337e+00, 4.229e+00, 4.599e+00 },
	{ 9.991e+00, 9.945e+00, 9.879e+00, 9.749e+00, 9.999e+01, 9.999e+01, 9.999e+01, 9.999e+01, 9.999e+01, 9.754e+00, 9.983e+00, 9.942e+00, 9.619e+00, 9.280e+00, 8.263e+00, 7.020e+00, 9.999e+01, 9.999e+01, 9.999e+01, 6.610e+00, 5.973e+00, 4.942e+00, 3.977e+00, 2.660e+00, 9.999e+01, 9.999e+01, 9.999e+01, 9.999e+01, 2.183e+00, 1.775e+00, 1.613e+00, 1.659e+00, 9.999e+01, 9.999e+01, 9.999e+01, 9.999e+01, 9.999e+01, 9.999e+01, 9.999e+01, 9.999e+01, 9.999e+01, 9.999e+01, 2.134e+00, 3.447e+00, 4.364e+00, 4.716e+00 },
	{ 9.981e+00, 9.946e+00, 9.889e+00, 9.755e+00, 9.999e+01, 9.999e+01, 9.999e+01, 9.999e+01, 9.999e+01, 9.697e+00, 9.955e+00, 9.911e+00, 9.592e+00, 9.276e+00, 8.725e+00, 7.914e+00, 7.449e+00, 7.141e+00, 6.799e+00, 6.360e+00, 5.764e+00, 5.064e+00, 4.182e+00, 3.044e+00, 2.558e+00, 2.489e+00, 2.430e+00, 2.355e+00, 2.330e+00, 2.109e+00, 1.912e+00, 1.761e+00, 9.999e+01, 9.999e+01, 9.999e+01, 9.999e+01, 9.999e+01, 9.999e+01, 9.999e+01, 9.999e+01, 9.999e+01, 9.999e+01, 2.128e+00, 3.483e+00, 4.491e+00, 4.836e+00 },
	{ 9.956e+00, 9.963e+00, 9.895e+00, 9.741e+00, 9.999e+01, 9.999e+01, 9.999e+01, 9.999e+01, 9.999e+01, 9.711e+00, 9.862e+00, 9.816e+00, 9.520e+00, 9.169e+00, 8.811e+00, 8.444e+00, 7.951e+00, 7.431e+00, 6.821e+00, 6.302e+00, 5.690e+00, 5.188e+00, 4.694e+00, 4.039e+00, 3.592e+00, 3.287e+00, 3.023e+00, 2.808e+00, 2.688e+00, 2.485e+00, 2.238e+00, 1.900e+00, 1.823e+00, 1.823e+00, 1.788e+00, 1.812e+00, 1.777e+00, 1.853e+00, 1.884e+00, 1.857e+00, 1.921e+00, 1.940e+00, 2.321e+00, 3.669e+00, 4.656e+00, 4.961e+00 },
	{ 9.824e+00, 9.962e+00, 9.884e+00, 9.747e+00, 9.999e+01, 9.999e+01, 9.999e+01, 9.999e+01, 9.999e+01, 9.719e+00, 9.719e+00, 9.710e+00, 9.419e+00, 9.089e+00, 8.741e+00, 8.351e+00, 7.896e+00, 7.415e+00, 6.924e+00, 6.373e+00, 5.861e+00, 5.370e+00, 4.867e+00, 4.420e+00, 4.030e+00, 3.731e+00, 3.474e+00, 3.213e+00, 3.011e+00, 2.823e+00, 2.641e+00, 2.332e+00, 2.162e+00, 2.162e+00, 2.264e+00, 2.264e+00, 2.355e+00, 2.487e+00, 2.642e+00, 2.772e+00, 2.938e+00, 3.112e+00, 3.430e+00, 4.166e+00, 4.854e+00, 5.133e+00 },
	{ 9.822e+00, 9.948e+00, 9.916e+00, 9.780e+00, 9.999e+01, 9.999e+01, 9.999e+01, 9.999e+01, 9.999e+01, 9.704e+00, 9.712e+00, 9.494e+00, 9.228e+00, 8.909e+00, 8.584e+00, 8.233e+00, 7.844e+00, 7.408e+00, 6.924e+00, 6.421e+00, 5.954e+00, 5.484e+00, 5.046e+00, 4.634e+00, 4.288e+00, 3.969e+00, 3.721e+00, 3.506e+00, 3.279e+00, 3.107e+00, 3.007e+00, 2.896e+00, 2.862e+00, 2.841e+00, 2.914e+00, 2.981e+00, 3.117e+00, 3.273e+00, 3.454e+00, 3.681e+00, 3.935e+00, 4.190e+00, 4.451e+00, 4.725e+00, 4.980e+00, 5.241e+00 }
};
#endif

static int nFreePoint;
static double qoc[lon][wid];
static double radiusR_low[n_sensor_URBAN];
static double radiusR_mid[n_sensor_URBAN];
static double radiusR_upp[n_sensor_URBAN];
static double angle_range_low[n_sensor_URBAN];
static double angle_range_mid[n_sensor_URBAN];
static double angle_range_upp[n_sensor_URBAN];
static double com_r[n_sensor_URBAN];
static double delta1[n_sensor_URBAN];
static double delta2[n_sensor_URBAN];

// static double myDistance[n_sensor_URBAN][n_sensor_URBAN];
static int connectstatus_sensor_relay[n_sensor_URBAN][n_relay_URBAN];
static int connectstatus_relay_relay[n_relay_URBAN][n_relay_URBAN];
// static int maxConnection;//×î´ó´«¸ÐÆ÷Á¬Í¨Êý

static double maxPathLoss;
static int avaiStatus_sense[n_sensor_URBAN];
static int avaiStatus_relay[n_relay_URBAN];
static double allPathLoss_s_r[n_sensor_URBAN][n_relay_URBAN];
static double allPathLoss_r_r[n_relay_URBAN][n_relay_URBAN];
static double pathloss2sink[n_relay_URBAN];
static int    ID_RELAY_HDSN_URBAN[n_relay_URBAN];

/////////////////////////////////////////////////////////////////////////////////////
// radio propagation reflection
#define MAX_PROPAGATION_MIRROR 128
static int mirror_num;
//static double prop_mirror_up[MAX_PROPAGATION_MIRROR];
//static double prop_mirror_down[MAX_PROPAGATION_MIRROR];
static double mirror_pos_north[MAX_PROPAGATION_MIRROR];//
static double mirror_pos_east[MAX_PROPAGATION_MIRROR];//
static double mirror_pos_south[MAX_PROPAGATION_MIRROR];//
static double mirror_pos_west[MAX_PROPAGATION_MIRROR];//
static int mirror_direction[MAX_PROPAGATION_MIRROR]; //reflect to: 0 - north; 1 - east; 2 - south; 3 - west
// static int flag_selection_mirror[MAX_PROPAGATION_MIRROR];
#define MAX_PROPAGATION_ITER 1024
static double prop_X[MAX_PROPAGATION_ITER];//virtual point
static double prop_Y[MAX_PROPAGATION_ITER];
static double prop_Z[MAX_PROPAGATION_ITER];
static double prop_angle_range[MAX_PROPAGATION_ITER][2];//clockwise
static int prop_mirror_ind[MAX_PROPAGATION_ITER];//index of a face of one building
static int prop_ind_parent[MAX_PROPAGATION_ITER];//where the reflection comes from
#define MAX_PROPAGATION_NUM_REFLECTION 3
static int prop_num_reflection[MAX_PROPAGATION_ITER];
static int prop_ind_start;
static int prop_ind_final;
static int flag_getAngle = 0;
static double prop_tmp_PL[MAX_PROPAGATION_ITER + 1];

/////////////////////////////////////////////////////////////////////////////////////

static double pos3D_DIREC[n_sensor_URBAN][3];
static double pos3D_RELAY[n_relay_URBAN][3];
//static int posCountBad;

//lifetime
#define energy_ini (10.0)
#define E_elec (50.0e-9)
#define e_fs (10.0e-12)
#define e_mp (0.0013e-12)
#define d_th (87.0)
#define E_DA (5.0e-9)
#define d_DA (0.1)
#define l0 (200)
#define n_rn_min (2)
#define d_th_sn (1.0/8.0*d_th)
#define d_th_rn (1.0/4.0*d_th)

static int hopID_SENSOR[n_sensor_URBAN];  // 0,1,2,...,N_RELAY-1, N_RELAY - SINK
static int hopID_RELAY[n_relay_URBAN];   // 0,1,2,...,N_RELAY-1, N_RELAY - SINK
static double com_pathloss_SENSOR[n_sensor_URBAN];
static double com_pathloss_RELAY[n_relay_URBAN];
static double n_data_local_RELAY[n_relay_URBAN];
static double n_data_hop_RELAY[n_relay_URBAN];
static double n_data_fwd_RELAY[n_relay_URBAN];

// static double std_dist_SENSOR;
static double energy_consumed_RELAY[n_relay_URBAN];
static double LT_RELAY[n_relay_URBAN];
// static double LT_avg;
//static int n_relia_p = 0;
//static double distNode2Relay[n_sensor_URBAN + n_relay_URBAN][n_relay_URBAN];

/***************************************************/
//o¡¥¨ºy¨¦¨´?¡Â
// static int RandomInteger(int low, int high);
static double rangeD(int i, int j, double h1, int a, int b, double h2); //?????¨¤¨¤?
static int LOS(int i, int j, double h1, int a, int b, double h2);
// static int LOS_building(int i, int j, double h1, int ind_mirror_fr,
//                         int a, int b, double h2, int ind_mirror_to);
static int LOS_double(double p1_X, double p1_Y, double p1_Z, int ind_mirror_fr,
	double p2_X, double p2_Y, double p2_Z, int ind_mirror_to);
static int LOS_building_double(double p1_X, double p1_Y, double p1_Z, int ind_mirror_fr,
	double p2_X, double p2_Y, double p2_Z, int ind_mirror_to);
static double Oq(int i, int j, int a, int b, double pan, double tilt, int k); //?????¨¬2a???¨º_new
static void Qoc(double* a);//??D?????QOC???¨®
static double Cover(double* a);//?????¡§¦Ì??2???¨º
static int Connectivity(double* a);//
static int CountObstacles(int i, int j, double h1, int a, int b, double h2, int* ind);
static double PathLossOne(int i, int j, double h1, int a, int b, double h2, double di);
// static double ConnectivityQuality(double* a);
static double ArcPan(int i, int j, int a, int b); //¡¤¦Ì??????¦Ì?¨®?¡ä??D?¡Â¦Ì?¦Ì??¡À??1?¨®¨²X?¨¢¦Ì????¨¨_new
static double ArcTilt(int i, int j, int a, int b); //tilt angle
// static double myErf(double a);
static double PropaPathLoss(int i, int j, double h1, int a, int b, double h2);
// static int getAngleRange(double _fr_X, double _fr_Y, double _fr_Z,
//                          int ind_prop_fr, int ind_mirror_fr,
//                          int ind_prop_to, int ind_mirror_to,
//                          int X_TX, int Y_TX, double Z_TX,
//                          int X_RX, int Y_RX, double Z_RX);
static int getAngleRange1(double _fr_X, double _fr_Y, double _fr_Z,
	int ind_prop_fr, int ind_mirror_fr,
	int ind_prop_to, int ind_mirror_to,
	int X_TX, int Y_TX, double Z_TX,
	int X_RX, int Y_RX, double Z_RX);
static int detectIntersection(double fr_X, double fr_Y, double fr_Z,
	double to_X, double to_Y, double to_Z,
	double& sect_X, double& sect_Y, double& sect_Z,
	int ind_mirror);
static double Lifetime();
/***************************************************/
//int main()
//{
//  int i, j, k, m, n;
//  srand(36);
//  for (k = 0; k < n_sensor_URBAN; k++) {
//      radiusR_low[k] = r_min + rand() / (RAND_MAX + 1.0) * (r_max - r_min); //printf("%9lf ", radiusR_low[k]);
//      radiusR_mid[k] = r_ratio_mid * radiusR_low[k];
//      radiusR_upp[k] = r_ratio_upp * radiusR_low[k];
//      angle_range_low[k] = angle_min + rand() / (RAND_MAX + 1.0) * (angle_max - angle_min); //printf("%9lf ", angle_range_low[k]);
//      angle_range_mid[k] = angle_ratio_mid * angle_range_low[k];
//      angle_range_upp[k] = angle_ratio_upp * angle_range_low[k];
//      com_r[k] = 1.1 * (radiusR_upp[k]); //printf("%9lf ", com_r[k]);
//      delta1[k] = 1.0;/* delta1_min + rand() / (RAND_MAX + 1.0) * (delta1_max - delta1_min);*/ //printf("%9lf ", delta1[k]);
//      delta2[k] = WHratio*delta1[k];/* delta2_min + rand() / (RAND_MAX + 1.0) * (delta2_max - delta2_min);*/ //printf("%9lf\n", delta2[k]);
//  }
//  //mirror
//  //row-wise
//  mirror_num = 0;
//  for (i = 1; i < lon; i++){
//      //north
//      j = 0;
//      while (j < wid){
//          if (map[i][j] < height_max){
//              j++;
//          }
//          else{
//              if (map[i - 1][j] < height_max){
//                  mirror_direction[mirror_num] = direction_north;
//                  mirror_pos_north[mirror_num] = i - 0.5;
//                  mirror_pos_south[mirror_num] = i - 0.5;
//                  mirror_pos_west[mirror_num] = j - 0.5;
//                  while (map[i][j] >= height_max && map[i - 1][j] < height_max){
//                      j++;
//                  }
//                  mirror_pos_east[mirror_num] = j - 1 + 0.5;
//                  if (mirror_pos_east[mirror_num] - mirror_pos_west[mirror_num] >= min_mirror_length){
//                      mirror_num++;
//                  }
//              }
//              else{
//                  j++;
//              }
//          }
//      }
//  }
//  for (i = 0; i < lon - 1; i++){
//      //south
//      j = 0;
//      while (j < wid){
//          if (map[i][j] < height_max){
//              j++;
//          }
//          else{
//              if (map[i + 1][j] < height_max){
//                  mirror_direction[mirror_num] = direction_south;
//                  mirror_pos_north[mirror_num] = i + 0.5;
//                  mirror_pos_south[mirror_num] = i + 0.5;
//                  mirror_pos_west[mirror_num] = j - 0.5;
//                  while (map[i][j] >= height_max && map[i + 1][j] < height_max){
//                      j++;
//                  }
//                  mirror_pos_east[mirror_num] = j - 1 + 0.5;
//                  if (mirror_pos_east[mirror_num] - mirror_pos_west[mirror_num] >= min_mirror_length){
//                      mirror_num++;
//                  }
//              }
//              else{
//                  j++;
//              }
//          }
//      }
//  }
//  //column-wise
//  for (i = 0; i < wid - 1; i++){
//      //east
//      j = 0;
//      while (j < lon){
//          if (map[j][i] < height_max){
//              j++;
//          }
//          else{
//              if (map[j][i + 1] < height_max){
//                  mirror_direction[mirror_num] = direction_east;
//                  mirror_pos_west[mirror_num] = i + 0.5;
//                  mirror_pos_east[mirror_num] = i + 0.5;
//                  mirror_pos_north[mirror_num] = j - 0.5;
//                  while (map[j][i] >= height_max && map[j][i + 1] < height_max){
//                      j++;
//                  }
//                  mirror_pos_south[mirror_num] = j - 1 + 0.5;
//                  if (mirror_pos_south[mirror_num] - mirror_pos_north[mirror_num] >= min_mirror_length){
//                      mirror_num++;
//                  }
//              }
//              else{
//                  j++;
//              }
//          }
//      }
//  }
//  for (i = 1; i < wid; i++){
//      //west
//      j = 0;
//      while (j < lon){
//          if (map[j][i] < height_max){
//              j++;
//          }
//          else{
//              if (map[j][i - 1] < height_max){
//                  mirror_direction[mirror_num] = direction_west;
//                  mirror_pos_west[mirror_num] = i - 0.5;
//                  mirror_pos_east[mirror_num] = i - 0.5;
//                  mirror_pos_north[mirror_num] = j - 0.5;
//                  while (map[j][i] >= height_max && map[j][i - 1] < height_max){
//                      j++;
//                  }
//                  mirror_pos_south[mirror_num] = j - 1 + 0.5;
//                  if (mirror_pos_south[mirror_num] - mirror_pos_north[mirror_num] >= min_mirror_length){
//                      mirror_num++;
//                  }
//              }
//              else{
//                  j++;
//              }
//          }
//      }
//  }
//  maxPathLoss = PathLossOne(0, 0, map[0][0], lon - 1, wid - 1, map[lon - 1][wid - 1], -1);
//  if (maxPathLoss < PathLossOne(lon - 1, wid - 1, map[lon - 1][wid - 1], 0, 0, map[0][0], -1)){
//      maxPathLoss = PathLossOne(lon - 1, wid - 1, map[lon - 1][wid - 1], 0, 0, map[0][0], -1);
//  }
//  nFreePoint = 0;
//  for (i = 0; i < lon; i++){
//      for (j = 0; j < wid; j++){
//          if (map[i][j] < height_max){
//              nFreePoint++;
//          }
//      }
//  }
//  srand(10);
//  double individual[DIM_HDSN_URBAN];
//  double fitness[HDSNOBJ_URBAN];
//  double fitness1[HDSNOBJ_URBAN];
//  double dur1 = 0;
//  double dur2 = 0;
//  double tm1, tm2;
//  double fit_diff_p = 0;
//  double fit_diff1_p = 0;
//  double fit_diff_n = 0;
//  double fit_diff1_n = 0;
//  int n1_p = 0, n2_p = 0;
//  int n1_n = 0, n2_n = 0;
//  n = 0;
//  while (n < 1000){
//      for (k = 0; k < n_sensor_URBAN; k++) {
//          individual[k * UNIT_URBAN + X] = RandomInteger(0, lon - 1);
//          individual[k * UNIT_URBAN + Y] = RandomInteger(0, wid - 1);
//          individual[k * UNIT_URBAN + PAN] = RandomInteger(0, 719) / 360.0 * pi;
//          individual[k * UNIT_URBAN + TILT] = RandomInteger(0, 719) / 720.0 * pi - pi / 2.0;
//      }
//      int offset = n_sensor_URBAN*UNIT_URBAN;
//      for (k = 0; k < n_relay_URBAN; k++){
//          individual[offset + k*UNIT_relay_URBAN + X] = RandomInteger(0, lon - 1);
//          individual[offset + k*UNIT_relay_URBAN + Y] = RandomInteger(0, wid - 1);
//      }
//      flag_getAngle = 0;
//      tm1 = clock();
//      Fitness_HDSN_URBAN(individual, fitness);
//      printf("coverage:%.9lf\n", fitness[0]);
//      printf("Connectivity quality:%.9lf\n", fitness[1]);
//      printf("Lifetime:%.9lf\n", fitness[2]);
//      dur1 += clock() - tm1;
//      flag_getAngle = 1;
//      tm2 = clock();
//      Fitness_HDSN_URBAN(individual, fitness1);
//      printf("coverage:%.9lf\n", fitness1[0]);
//      printf("Connectivity quality:%.9lf\n", fitness1[1]);
//      printf("Lifetime:%.9lf\n", fitness1[2]);
//      dur2 += clock() - tm2;
//      printf("\n");
//      if (fitness[1] < fitness1[1]){
//          fit_diff_n += (fitness[1] - fitness1[1]);
//          n1_n++;
//      }
//      if (fitness[1] > fitness1[1]){
//          fit_diff_p += (fitness[1] - fitness1[1]);
//          n1_p++;
//      }
//      if (fitness[2] < fitness1[2]){
//          fit_diff1_n += (fitness[2] - fitness1[2]);
//          n2_n++;
//      }
//      if (fitness[2] > fitness1[2]){
//          fit_diff1_p += (fitness[2] - fitness1[2]);
//          n2_p++;
//      }
//      printf("diff: %lf - %lf\n", (fitness[1] - fitness1[1]),
//          (fitness[2] - fitness1[2]));
//      n++;
//  }
//  dur1 = dur1 / CLOCKS_PER_SEC;
//  dur2 = dur2 / CLOCKS_PER_SEC;
//  printf("DIFF: %e (%d) %e (%d) --- %e (%d) %e (%d)\n",
//      fit_diff_n / n1_n, n1_n, fit_diff_p / n1_p, n1_p,
//      fit_diff1_n / n2_n, n2_n, fit_diff1_p / n2_p, n2_p);
//  printf("TIME: %es --- %es\n", dur1, dur2);
//  return 0;
//}
void SetLimits_HDSN_URBAN(double* minLimit, double* maxLimit, int nx)
{
	int i, j, k;// , m, n;
	for (k = 0; k < n_sensor_URBAN; k++) {
		minLimit[k * UNIT_URBAN + X] = 0;
		minLimit[k * UNIT_URBAN + Y] = 0;
		minLimit[k * UNIT_URBAN + PAN] = 0;
		minLimit[k * UNIT_URBAN + TILT] = -pi / 2.0;
		maxLimit[k * UNIT_URBAN + X] = lon - 1e-10;
		maxLimit[k * UNIT_URBAN + Y] = wid - 1e-10;
		maxLimit[k * UNIT_URBAN + PAN] = 2 * pi - 1e-10;
		maxLimit[k * UNIT_URBAN + TILT] = pi / 2.0;
	}
	int offset = n_sensor_URBAN * UNIT_URBAN;
	for (k = 0; k < n_relay_URBAN; k++) {
		minLimit[offset + k * UNIT_relay_URBAN + X] = 0;
		minLimit[offset + k * UNIT_relay_URBAN + Y] = 0;
		maxLimit[offset + k * UNIT_relay_URBAN + X] = lon - 1e-10;
		maxLimit[offset + k * UNIT_relay_URBAN + Y] = wid - 1e-10;
	}
	//mirror
	//row-wise
	mirror_num = 0;
	for (i = 1; i < lon; i++) {
		//north
		j = 0;
		while (j < wid) {
			if (map[i][j] < height_max) {
				j++;
			}
			else {
				if (map[i - 1][j] < height_max) {
					mirror_direction[mirror_num] = direction_north;
					mirror_pos_north[mirror_num] = i - 0.5;
					mirror_pos_south[mirror_num] = i - 0.5;
					mirror_pos_west[mirror_num] = j - 0.5;
					while (map[i][j] >= height_max && map[i - 1][j] < height_max) {
						j++;
					}
					mirror_pos_east[mirror_num] = j - 1 + 0.5;
					if (mirror_pos_east[mirror_num] - mirror_pos_west[mirror_num] >= min_mirror_length) {
						mirror_num++;
					}
				}
				else {
					j++;
				}
			}
		}
	}
	for (i = 0; i < lon - 1; i++) {
		//south
		j = 0;
		while (j < wid) {
			if (map[i][j] < height_max) {
				j++;
			}
			else {
				if (map[i + 1][j] < height_max) {
					mirror_direction[mirror_num] = direction_south;
					mirror_pos_north[mirror_num] = i + 0.5;
					mirror_pos_south[mirror_num] = i + 0.5;
					mirror_pos_west[mirror_num] = j - 0.5;
					while (map[i][j] >= height_max && map[i + 1][j] < height_max) {
						j++;
					}
					mirror_pos_east[mirror_num] = j - 1 + 0.5;
					if (mirror_pos_east[mirror_num] - mirror_pos_west[mirror_num] >= min_mirror_length) {
						mirror_num++;
					}
				}
				else {
					j++;
				}
			}
		}
	}
	//column-wise
	for (i = 0; i < wid - 1; i++) {
		//east
		j = 0;
		while (j < lon) {
			if (map[j][i] < height_max) {
				j++;
			}
			else {
				if (map[j][i + 1] < height_max) {
					mirror_direction[mirror_num] = direction_east;
					mirror_pos_west[mirror_num] = i + 0.5;
					mirror_pos_east[mirror_num] = i + 0.5;
					mirror_pos_north[mirror_num] = j - 0.5;
					while (map[j][i] >= height_max && map[j][i + 1] < height_max) {
						j++;
					}
					mirror_pos_south[mirror_num] = j - 1 + 0.5;
					if (mirror_pos_south[mirror_num] - mirror_pos_north[mirror_num] >= min_mirror_length) {
						mirror_num++;
					}
				}
				else {
					j++;
				}
			}
		}
	}
	for (i = 1; i < wid; i++) {
		//west
		j = 0;
		while (j < lon) {
			if (map[j][i] < height_max) {
				j++;
			}
			else {
				if (map[j][i - 1] < height_max) {
					mirror_direction[mirror_num] = direction_west;
					mirror_pos_west[mirror_num] = i - 0.5;
					mirror_pos_east[mirror_num] = i - 0.5;
					mirror_pos_north[mirror_num] = j - 0.5;
					while (map[j][i] >= height_max && map[j][i - 1] < height_max) {
						j++;
					}
					mirror_pos_south[mirror_num] = j - 1 + 0.5;
					if (mirror_pos_south[mirror_num] - mirror_pos_north[mirror_num] >= min_mirror_length) {
						mirror_num++;
					}
				}
				else {
					j++;
				}
			}
		}
	}
	maxPathLoss = PathLossOne(0, 0, map[0][0], lon - 1, wid - 1, map[lon - 1][wid - 1], -1);
	if (maxPathLoss < PathLossOne(lon - 1, wid - 1, map[lon - 1][wid - 1], 0, 0, map[0][0], -1)) {
		maxPathLoss = PathLossOne(lon - 1, wid - 1, map[lon - 1][wid - 1], 0, 0, map[0][0], -1);
	}
	nFreePoint = 0;
	for (i = 0; i < lon; i++) {
		for (j = 0; j < wid; j++) {
			if (map[i][j] < height_max) {
				nFreePoint++;
			}
		}
	}
	srand(36);
	for (k = 0; k < n_sensor_URBAN; k++) {
		radiusR_low[k] = r_min + rand() / (RAND_MAX + 1.0) * (r_max - r_min); //printf("%9lf ", radiusR_low[k]);
		radiusR_mid[k] = r_ratio_mid * radiusR_low[k];
		radiusR_upp[k] = r_ratio_upp * radiusR_low[k];
		angle_range_low[k] = angle_min + rand() / (RAND_MAX + 1.0) * (angle_max - angle_min); //printf("%9lf ", angle_range_low[k]);
		angle_range_mid[k] = angle_ratio_mid * angle_range_low[k];
		angle_range_upp[k] = angle_ratio_upp * angle_range_low[k];
		com_r[k] = 1.1 * (radiusR_upp[k]); //printf("%9lf ", com_r[k]);
		delta1[k] = 1.0;/* delta1_min + rand() / (RAND_MAX + 1.0) * (delta1_max - delta1_min);*/ //printf("%9lf ", delta1[k]);
		delta2[k] = WHratio *
			delta1[k];/* delta2_min + rand() / (RAND_MAX + 1.0) * (delta2_max - delta2_min);*/ //printf("%9lf\n", delta2[k]);
	}
}
int CheckLimits_HDSN_URBAN(double* x, int nx)
{
	int k;
	for (k = 0; k < n_sensor_URBAN; k++) {
		if (x[k * UNIT_URBAN + X] < 0 || x[k * UNIT_URBAN + X] > lon - 1e-10) {
			printf("Check limits FAIL - HDSN: %d, %.16e not in [%.16e, %.16e]\n",
				k * UNIT_URBAN + X, x[k * UNIT_URBAN + X], 0.0, lon - 1.0e-10);
			return false;
		}
		if (x[k * UNIT_URBAN + Y] < 0 || x[k * UNIT_URBAN + Y] > wid - 1e-10) {
			printf("Check limits FAIL - HDSN: %d, %.16e not in [%.16e, %.16e]\n",
				k * UNIT_URBAN + Y, x[k * UNIT_URBAN + Y], 0.0, wid - 1.0e-10);
			return false;
		}
		if (x[k * UNIT_URBAN + PAN] < 0 || x[k * UNIT_URBAN + PAN] > 2 * pi - 1e-10) {
			printf("Check limits FAIL - HDSN: %d, %.16e not in [%.16e, %.16e]\n",
				k * UNIT_URBAN + PAN, x[k * UNIT_URBAN + PAN], 0.0, 2 * pi - 1e-10);
			return false;
		}
		if (x[k * UNIT_URBAN + TILT] < -pi / 2.0 || x[k * UNIT_URBAN + TILT] > pi / 2.0) {
			printf("Check limits FAIL - HDSN: %d, %.16e not in [%.16e, %.16e]\n",
				k * UNIT_URBAN + TILT, x[k * UNIT_URBAN + TILT], -pi / 2.0, pi / 2.0);
			return false;
		}
	}
	int offset = n_sensor_URBAN * UNIT_URBAN;
	for (k = 0; k < n_relay_URBAN; k++) {
		if (x[offset + k * UNIT_relay_URBAN + X] < 0 || x[offset + k * UNIT_relay_URBAN + X] > lon - 1e-10) {
			printf("Check limits FAIL - HDSN: %d, %.16e not in [%.16e, %.16e]\n",
				offset + k * UNIT_relay_URBAN + X, x[offset + k * UNIT_relay_URBAN + X], 0.0, lon - 1.0e-10);
			return false;
		}
		if (x[offset + k * UNIT_relay_URBAN + Y] < 0 || x[offset + k * UNIT_relay_URBAN + Y] > wid - 1e-10) {
			printf("Check limits FAIL - HDSN: %d, %.16e not in [%.16e, %.16e]\n",
				offset + k * UNIT_relay_URBAN + Y, x[offset + k * UNIT_relay_URBAN + Y], 0.0, wid - 1.0e-10);
			return false;
		}
	}
	return true;
}
// static int RandomInteger(int low, int high)
// {
//     return (low + (int)(rand() / (RAND_MAX + 1.0) * (high - low + 1)));
// }
static double rangeD(int i, int j, double h1, int a, int b, double h2)
{
	return (sqrt((double)((i - a) * (i - a) + (j - b) * (j - b) + (h1 - h2) / resolution * (h1 - h2) / resolution)));
}
static int LOS(int i, int j, double h1, int a, int b, double h2)
{
	double h = h1;
	double cc = h2;
	int m;
	int x, y, x1, y1;
	double z1, z2,
		z;  //z?????¡À??¨¦?¦Ì????¨¨   x?¡éy?a¨¢?¦Ì?o¨¢¡ÁY¡Á?¡À¨º2?¡ê¡§?y??¨ºy¡ê? x1?a¦Ì£¤??2?¨¢?¡ê¡§¡ä?¡¤?o?¡ê? z1?¡éz2¦Ì?D?¦Ì?¡Á?¡À¨º¦Ì????¨¨
	double k, k1;          //¨¢?¦Ì?3¨¦??¦Ì?D¡À?¨º
	double x2;            //¨®?¨®¨²¡ä?¡ä¡é?¨´?¨®¦Ì?¡Á?¡À¨º
	double y2;
	int x3;
	int y3;             //??y2??D??¡¥
	x = abs(a - i);    //¨¢?¦Ì???¦Ì?¡Á?¡À¨º2?
	y = abs(b - j);
	if (x >= y) {
		if (i != a) {
			x1 = (a - i) / x;         //¡ä??y?o¨ºy
			k = ((double)(b - j)) / ((double)(a - i));
			k1 = ((double)(cc - h)) / (a - i);
			for (m = 1; m < x; m++) {
				x2 = i + x1 * m;
				y2 = k * (x2 - i) + j;
				z = k1 * (x2 - i) + h; ////x?¡éy?¡éz¡Á?¡À¨º¡ê¡§?¡À??¡ê?
				if (y2 == (int)y2) {
					x3 = (int)x2;
					y3 = (int)y2;
					z1 = map[x3][y3];
					if (z < z1) {
						return 0;
					}
				}
				else {
					x3 = (int)x2;
					y3 = (int)y2;
					z1 = map[x3][y3];
					y3 = y3 + 1;//²»»áÔ½½ç
					z2 = map[x3][y3];
					if (z < z1 || z < z2) {
						return 0;
					}
				}
			}
		}
	}
	else {
		if (j != b) {
			y1 = (b - j) / y;         //¡ä??y?o¨ºy
			k = ((double)(a - i)) / ((double)(b - j));
			k1 = ((double)(cc - h)) / (b - j);
			for (m = 1; m < y; m++) {
				y2 = j + y1 * m;
				x2 = k * (y2 - j) + i;
				z = k1 * (y2 - j) + h;
				if (x2 == (int)x2) {
					x3 = (int)x2;
					y3 = (int)y2;
					z1 = map[x3][y3];
					if (z < z1) {
						return 0;
					}
				}
				else {
					x3 = (int)x2;
					y3 = (int)y2;
					z1 = map[x3][y3];
					x3 = x3 + 1;//²»»áÔ½½ç
					z2 = map[x3][y3];
					if (z < z1 || z < z2) {
						return 0;
					}
				}
			}
		}
	}
	return 1;
}
// static int LOS_building(int i, int j, double h1, int ind_mirror_fr,
//                         int a, int b, double h2, int ind_mirror_to)
// {
//     // double h = h1;
//     // double cc = h2;
//     int m;
//     int x, y, x1, y1;
//     double z1, z2;  //z?????¡À??¨¦?¦Ì????¨¨   x?¡éy?a¨¢?¦Ì?o¨¢¡ÁY¡Á?¡À¨º2?¡ê¡§?y??¨ºy¡ê? x1?a¦Ì£¤??2?¨¢?¡ê¡§¡ä?¡¤?o?¡ê? z1?¡éz2¦Ì?D?¦Ì?¡Á?¡À¨º¦Ì????¨¨
//     double k;          //¨¢?¦Ì?3¨¦??¦Ì?D¡À?¨º
//     double x2;            //¨®?¨®¨²¡ä?¡ä¡é?¨´?¨®¦Ì?¡Á?¡À¨º
//     double y2;
//     int x3;
//     int y3;             //??y2??D??¡¥
//     x = abs(a - i);    //¨¢?¦Ì???¦Ì?¡Á?¡À¨º2?
//     y = abs(b - j);
//     int X_skip1, X_skip2;
//     int Y_skip1, Y_skip2;
//     switch (mirror_direction[ind_mirror_fr]) {
//     case direction_north:
//         X_skip1 = (int)(mirror_pos_north[ind_mirror_fr]) + 1;
//         Y_skip1 = -1;
//         break;
//     case direction_east:
//         X_skip1 = -1;
//         Y_skip1 = (int)(mirror_pos_east[ind_mirror_fr]);
//         break;
//     case direction_south:
//         X_skip1 = (int)(mirror_pos_south[ind_mirror_fr]);
//         Y_skip1 = -1;
//         break;
//     case direction_west:
//         X_skip1 = -1;
//         Y_skip1 = (int)(mirror_pos_west[ind_mirror_fr]) + 1;
//     default:
//         X_skip1 = -1;
//         Y_skip1 = -1;
//         break;
//     }
//     switch (mirror_direction[ind_mirror_to]) {
//     case direction_north:
//         X_skip2 = (int)(mirror_pos_north[ind_mirror_to]) + 1;
//         Y_skip2 = -1;
//         break;
//     case direction_east:
//         X_skip2 = -1;
//         Y_skip2 = (int)(mirror_pos_east[ind_mirror_to]);
//         break;
//     case direction_south:
//         X_skip2 = (int)(mirror_pos_south[ind_mirror_to]);
//         Y_skip2 = -1;
//         break;
//     case direction_west:
//         X_skip2 = -1;
//         Y_skip2 = (int)(mirror_pos_west[ind_mirror_to]) + 1;
//     default:
//         X_skip2 = -1;
//         Y_skip2 = -1;
//         break;
//     }
//     if (x >= y) {
//         if (i != a) {
//             x1 = (a - i) / x;         //¡ä??y?o¨ºy
//             k = ((double)(b - j)) / ((double)(a - i));
//             // k1 = ((double)(cc - h)) / (a - i);
//             for (m = 1; m < x; m++) {
//                 x2 = i + x1 * m;
//                 if ((int)x2 == X_skip1 || (int)x2 == X_skip2)
//                     continue;
//                 y2 = k * (x2 - i) + j;
//                 //z = k1 * (x2 - i) + h; ////x?¡éy?¡éz¡Á?¡À¨º¡ê¡§?¡À??¡ê?
//                 if (y2 == (int)y2) {
//                     x3 = (int)x2;
//                     y3 = (int)y2;
//                     z1 = map[x3][y3];
//                     if ((int)y3 != Y_skip1 && (int)y3 != Y_skip2 && z1 >= height_max) {
//                         return 0;
//                     }
//                 } else {
//                     x3 = (int)x2;
//                     y3 = (int)y2;
//                     z1 = map[x3][y3];
//                     if ((int)y3 != Y_skip1 && (int)y3 != Y_skip2 && z1 >= height_max) {
//                         return 0;
//                     }
//                     y3 = y3 + 1;//²»»áÔ½½ç
//                     z2 = map[x3][y3];
//                     if ((int)y3 != Y_skip1 && (int)y3 != Y_skip2 && z2 >= height_max) {
//                         return 0;
//                     }
//                 }
//             }
//         }
//     } else {
//         if (j != b) {
//             y1 = (b - j) / y;         //¡ä??y?o¨ºy
//             k = ((double)(a - i)) / ((double)(b - j));
//             // k1 = ((double)(cc - h)) / (b - j);
//             for (m = 1; m < y; m++) {
//                 y2 = j + y1 * m;
//                 if ((int)y2 == Y_skip1 && (int)y2 == Y_skip2)
//                     continue;
//                 x2 = k * (y2 - j) + i;
//                 //z = k1*(y2 - j) + h;
//                 if (x2 == (int)x2) {
//                     x3 = (int)x2;
//                     y3 = (int)y2;
//                     z1 = map[x3][y3];
//                     if ((int)x3 != X_skip1 && (int)x3 != X_skip2 && z1 >= height_max) {
//                         return 0;
//                     }
//                 } else {
//                     x3 = (int)x2;
//                     y3 = (int)y2;
//                     z1 = map[x3][y3];
//                     if ((int)x3 != X_skip1 && (int)x3 != X_skip2 && z1 >= height_max) {
//                         return 0;
//                     }
//                     x3 = x3 + 1;//²»»áÔ½½ç
//                     z2 = map[x3][y3];
//                     if ((int)x3 != X_skip1 && (int)x3 != X_skip2 && z2 >= height_max) {
//                         return 0;
//                     }
//                 }
//             }
//         }
//     }
//     return 1;
// }
static int LOS_double(double p1_X, double p1_Y, double p1_Z, int ind_mirror_fr,
	double p2_X, double p2_Y, double p2_Z, int ind_mirror_to)
{
	int m;
	double x, y;
	double z1, z2,
		z;  //z?????¡À??¨¦?¦Ì????¨¨   x?¡éy?a¨¢?¦Ì?o¨¢¡ÁY¡Á?¡À¨º2?¡ê¡§?y??¨ºy¡ê? x1?a¦Ì£¤??2?¨¢?¡ê¡§¡ä?¡¤?o?¡ê? z1?¡éz2¦Ì?D?¦Ì?¡Á?¡À¨º¦Ì????¨¨
	double k, k1;          //¨¢?¦Ì?3¨¦??¦Ì?D¡À?¨º
	double x2;            //¨®?¨®¨²¡ä?¡ä¡é?¨´?¨®¦Ì?¡Á?¡À¨º
	double y2;
	int x3;
	int y3;             //??y2??D??¡¥
	x = fabs(p2_X - p1_X);    //¨¢?¦Ì???¦Ì?¡Á?¡À¨º2?
	y = fabs(p2_Y - p1_Y);
	int X_skip1, X_skip2;
	int Y_skip1, Y_skip2;
	switch (mirror_direction[ind_mirror_fr]) {
	case direction_north:
		X_skip1 = (int)(mirror_pos_north[ind_mirror_fr]) + 1;
		Y_skip1 = -1;
		break;
	case direction_east:
		X_skip1 = -1;
		Y_skip1 = (int)(mirror_pos_east[ind_mirror_fr]);
		break;
	case direction_south:
		X_skip1 = (int)(mirror_pos_south[ind_mirror_fr]);
		Y_skip1 = -1;
		break;
	case direction_west:
		X_skip1 = -1;
		Y_skip1 = (int)(mirror_pos_west[ind_mirror_fr]) + 1;
		break;////////////////////////////////////////////////
	default:
		X_skip1 = -1;
		Y_skip1 = -1;
		break;
	}
	switch (mirror_direction[ind_mirror_to]) {
	case direction_north:
		X_skip2 = (int)(mirror_pos_north[ind_mirror_to]) + 1;
		Y_skip2 = -1;
		break;
	case direction_east:
		X_skip2 = -1;
		Y_skip2 = (int)(mirror_pos_east[ind_mirror_to]);
		break;
	case direction_south:
		X_skip2 = (int)(mirror_pos_south[ind_mirror_to]);
		Y_skip2 = -1;
		break;
	case direction_west:
		X_skip2 = -1;
		Y_skip2 = (int)(mirror_pos_west[ind_mirror_to]) + 1;
		break;////////////////////////////////////////////////
	default:
		X_skip2 = -1;
		Y_skip2 = -1;
		break;
	}
	if (x >= y) {
		if (p1_X != p2_X) {
			int X_stt, X_end;
			if (p1_X > p2_X) {
				X_stt = (int)(p2_X)+1;
				X_end = (int)(p1_X);
			}
			else {
				X_stt = (int)(p1_X)+1;
				X_end = (int)(p2_X);
			}
			k = (p2_Y - p1_Y) / (p2_X - p1_X);
			k1 = (p2_Z - p1_Z) / (p2_X - p1_X);
			for (m = X_stt; m <= X_end; m++) {
				x2 = m;
				if ((int)x2 == X_skip1 || (int)x2 == X_skip2)
					continue;
				if ((int)x2 < 0 || (int)x2 >= lon)
					continue;
				y2 = k * (x2 - p1_X) + p1_Y;
				z = k1 * (x2 - p1_X) + p1_Z; ////x?¡éy?¡éz¡Á?¡À¨º¡ê¡§?¡À??¡ê?
				if (y2 == (int)y2) {
					x3 = (int)x2;
					y3 = (int)y2;
					if ((int)y3 < 0 || (int)y3 >= wid)
						continue;
					z1 = map[x3][y3];
					if ((int)y3 != Y_skip1 && (int)y3 != Y_skip2 && z < z1) {
						return 0;
					}
				}
				else {
					x3 = (int)x2;
					y3 = (int)y2;
					if ((int)y3 < 0 || (int)y3 >= wid)
						z1 = -1;
					else
						z1 = map[x3][y3];
					if ((int)y3 != Y_skip1 && (int)y3 != Y_skip2 && z < z1) {
						return 0;
					}
					y3 = y3 + 1;//²»»áÔ½½ç
					if ((int)y3 < 0 || (int)y3 >= wid)
						z2 = -1;
					else
						z2 = map[x3][y3];
					if ((int)y3 != Y_skip1 && (int)y3 != Y_skip2 && z < z2) {
						return 0;
					}
				}
			}
		}
	}
	else {
		if (p1_Y != p2_Y) {
			int Y_stt, Y_end;
			if (p1_Y > p2_Y) {
				Y_stt = (int)(p2_Y)+1;
				Y_end = (int)(p1_Y);
			}
			else {
				Y_stt = (int)(p1_Y)+1;
				Y_end = (int)(p2_Y);
			}
			k = (p2_X - p1_X) / (p2_Y - p1_Y);
			k1 = (p2_Z - p1_Z) / (p2_Y - p1_Y);
			for (m = Y_stt; m <= Y_end; m++) {
				y2 = m;
				if ((int)y2 == Y_skip1 && (int)y2 == Y_skip2)
					continue;
				if ((int)y2 < 0 || (int)y2 >= wid)
					continue;
				x2 = k * (y2 - p1_Y) + p1_X;
				z = k1 * (y2 - p1_Y) + p1_Z;
				if (x2 == (int)x2) {
					x3 = (int)x2;
					y3 = (int)y2;
					if ((int)x3 < 0 || (int)x3 >= lon)
						continue;
					z1 = map[x3][y3];
					if ((int)x3 != X_skip1 && (int)x3 != X_skip2 && z < z1) {
						return 0;
					}
				}
				else {
					x3 = (int)x2;
					y3 = (int)y2;
					if ((int)x3 < 0 || (int)x3 >= lon)
						z1 = -1;
					else
						z1 = map[x3][y3];
					if ((int)x3 != X_skip1 && (int)x3 != X_skip2 && z < z1) {
						return 0;
					}
					x3 = x3 + 1;//²»»áÔ½½ç
					if ((int)x3 < 0 || (int)x3 >= lon)
						z2 = -1;
					else
						z2 = map[x3][y3];
					if ((int)x3 != X_skip1 && (int)x3 != X_skip2 && z < z2) {
						return 0;
					}
				}
			}
		}
	}
	return 1;
}
static int LOS_building_double(double p1_X, double p1_Y, double p1_Z, int ind_mirror_fr,
	double p2_X, double p2_Y, double p2_Z, int ind_mirror_to)
{
	int m;
	double x, y;
	double z1,
		z2;  //z?????¡À??¨¦?¦Ì????¨¨   x?¡éy?a¨¢?¦Ì?o¨¢¡ÁY¡Á?¡À¨º2?¡ê¡§?y??¨ºy¡ê? x1?a¦Ì£¤??2?¨¢?¡ê¡§¡ä?¡¤?o?¡ê? z1?¡éz2¦Ì?D?¦Ì?¡Á?¡À¨º¦Ì????¨¨
	double k;          //¨¢?¦Ì?3¨¦??¦Ì?D¡À?¨º
	double x2;            //¨®?¨®¨²¡ä?¡ä¡é?¨´?¨®¦Ì?¡Á?¡À¨º
	double y2;
	int x3;
	int y3;             //??y2??D??¡¥
	x = fabs(p2_X - p1_X);    //¨¢?¦Ì???¦Ì?¡Á?¡À¨º2?
	y = fabs(p2_Y - p1_Y);
	int X_skip1, X_skip2;
	int Y_skip1, Y_skip2;
	switch (mirror_direction[ind_mirror_fr]) {
	case direction_north:
		X_skip1 = (int)(mirror_pos_north[ind_mirror_fr]) + 1;
		Y_skip1 = -1;
		break;
	case direction_east:
		X_skip1 = -1;
		Y_skip1 = (int)(mirror_pos_east[ind_mirror_fr]);
		break;
	case direction_south:
		X_skip1 = (int)(mirror_pos_south[ind_mirror_fr]);
		Y_skip1 = -1;
		break;
	case direction_west:
		X_skip1 = -1;
		Y_skip1 = (int)(mirror_pos_west[ind_mirror_fr]) + 1;
		break;////////////////////////////////////////////////
	default:
		X_skip1 = -1;
		Y_skip1 = -1;
		break;
	}
	switch (mirror_direction[ind_mirror_to]) {
	case direction_north:
		X_skip2 = (int)(mirror_pos_north[ind_mirror_to]) + 1;
		Y_skip2 = -1;
		break;
	case direction_east:
		X_skip2 = -1;
		Y_skip2 = (int)(mirror_pos_east[ind_mirror_to]);
		break;
	case direction_south:
		X_skip2 = (int)(mirror_pos_south[ind_mirror_to]);
		Y_skip2 = -1;
		break;
	case direction_west:
		X_skip2 = -1;
		Y_skip2 = (int)(mirror_pos_west[ind_mirror_to]) + 1;
		break;////////////////////////////////////////////////
	default:
		X_skip2 = -1;
		Y_skip2 = -1;
		break;
	}
	if (x >= y) {
		if (p1_X != p2_X) {
			int X_stt, X_end;
			if (p1_X > p2_X) {
				X_stt = (int)(p2_X)+1;
				X_end = (int)(p1_X);
			}
			else {
				X_stt = (int)(p1_X)+1;
				X_end = (int)(p2_X);
			}
			k = (p2_Y - p1_Y) / (p2_X - p1_X);
			// k1 = (p2_Z - p1_Z) / (p2_X - p1_X);
			for (m = X_stt; m <= X_end; m++) {
				x2 = m;
				if ((int)x2 == X_skip1 || (int)x2 == X_skip2)
					continue;
				if ((int)x2 < 0 || (int)x2 >= lon)
					continue;
				y2 = k * (x2 - p1_X) + p1_Y;
				// z = k1 * (x2 - p1_X) + p1_Z; ////x?¡éy?¡éz¡Á?¡À¨º¡ê¡§?¡À??¡ê?
				if (y2 == (int)y2) {
					x3 = (int)x2;
					y3 = (int)y2;
					if ((int)y3 < 0 || (int)y3 >= wid)
						continue;
					z1 = map[x3][y3];
					if ((int)y3 != Y_skip1 && (int)y3 != Y_skip2 && z1 >= height_max) {
						return 0;
					}
				}
				else {
					x3 = (int)x2;
					y3 = (int)y2;
					if ((int)y3 < 0 || (int)y3 >= wid)
						z1 = -1;
					else
						z1 = map[x3][y3];
					if ((int)y3 != Y_skip1 && (int)y3 != Y_skip2 && z1 >= height_max) {
						return 0;
					}
					y3 = y3 + 1;//²»»áÔ½½ç
					if ((int)y3 < 0 || (int)y3 >= wid)
						z2 = -1;
					else
						z2 = map[x3][y3];
					if ((int)y3 != Y_skip1 && (int)y3 != Y_skip2 && z2 >= height_max) {
						return 0;
					}
				}
			}
		}
	}
	else {
		if (p1_Y != p2_Y) {
			int Y_stt, Y_end;
			if (p1_Y > p2_Y) {
				Y_stt = (int)(p2_Y)+1;
				Y_end = (int)(p1_Y);
			}
			else {
				Y_stt = (int)(p1_Y)+1;
				Y_end = (int)(p2_Y);
			}
			k = (p2_X - p1_X) / (p2_Y - p1_Y);
			// k1 = (p2_Z - p1_Z) / (p2_Y - p1_Y);
			for (m = Y_stt; m <= Y_end; m++) {
				y2 = m;
				if ((int)y2 == Y_skip1 && (int)y2 == Y_skip2)
					continue;
				if ((int)y2 < 0 || (int)y2 >= wid)
					continue;
				x2 = k * (y2 - p1_Y) + p1_X;
				// z = k1 * (y2 - p1_Y) + p1_Z;
				if (x2 == (int)x2) {
					x3 = (int)x2;
					y3 = (int)y2;
					if ((int)x3 < 0 || (int)x3 >= lon)
						continue;
					z1 = map[x3][y3];
					if ((int)x3 != X_skip1 && (int)x3 != X_skip2 && z1 >= height_max) {
						return 0;
					}
				}
				else {
					x3 = (int)x2;
					y3 = (int)y2;
					if ((int)x3 < 0 || (int)x3 >= lon)
						z1 = -1;
					else
						z1 = map[x3][y3];
					if ((int)x3 != X_skip1 && (int)x3 != X_skip2 && z1 >= height_max) {
						return 0;
					}
					x3 = x3 + 1;//²»»áÔ½½ç
					if ((int)x3 < 0 || (int)x3 >= lon)
						z2 = -1;
					else
						z2 = map[x3][y3];
					if ((int)x3 != X_skip1 && (int)x3 != X_skip2 && z2 >= height_max) {
						return 0;
					}
				}
			}
		}
	}
	return 1;
}
static double Oq(int i, int j, int a, int b, double pan, double tilt, int k) //¡ä??D?¡Â????¨®?????¦Ì?,an?a[0,2pi)
{
	double r;        //¨®?¨®¨²¡ä?¡¤???¡À¨º????¨®???¡À¨º¡ä??D?¡Â¦Ì??¨¤¨¤?range (s,p)
	if (i == a && j == b)  //¨¢?¦Ì???o?¡ê??2???¨¨?a1
		return 1.0;
	if (LOS(i, j, map[i][j], a, b, map[a][b])) {
		r = rangeD(i, j, map[i][j], a, b, map[a][b]);
		pan = pan - ArcPan(i, j, a, b); //an?a(-2pi,2pi)
		if (pan < 0)
			pan = -pan; //[0,2pi)
		if (pan > pi)
			pan = 2 * pi - pan; //anÎª[0,pi]£¬ÏñËØµãÏà¶Ô´«¸ÐÆ÷µÄÆ«×ª½Ç
		//printf("%f\t",pan);
		tilt = tilt - ArcTilt(i, j, a, b);
		if (tilt < 0)
			tilt = -tilt;
		if (tilt > pi)
			tilt = 2 * pi - tilt;
		//printf("%f\n",tilt);
		double prob_d, prob_angle1, prob_angle2, angle_mix;// , prob_angle;
		//angle_mix = sqrt(pow(pan / delta1[k], 2) + pow(tilt / delta2[k], 2));
		if (r <= radiusR_low[k])
			prob_d = 1.0;
		else if (r > radiusR_low[k] && r <= radiusR_mid[k]) {
			prob_d = 1 - vi1 * exp(tan(pi / 2.0 * (pow((r - radiusR_low[k]) / (radiusR_mid[k] - radiusR_low[k]), omega1) - 1.0)));
			//printf("mid->%lf->%lf->%lf\n",r - radiusR_low[k],radiusR_mid[k] - radiusR_low[k],prob_d);
		}
		else if (r > radiusR_mid[k] && r < radiusR_upp[k]) {
			prob_d = 0 + vi2 * exp(tan(pi / 2.0 * (pow((radiusR_upp[k] - r) / (radiusR_upp[k] - radiusR_mid[k]), omega2) - 1.0)));
			//printf("upp->%lf->%lf->%lf\n",radiusR_upp[k] - r,radiusR_upp[k] - radiusR_mid[k],prob_d);
		}
		else
			prob_d = 0.0;
		angle_mix = pan / delta1[k];
		if (angle_mix <= angle_range_low[k])
			prob_angle1 = 1.0;
		else if (angle_mix > angle_range_low[k] && angle_mix <= angle_range_mid[k]) {
			prob_angle1 = 1 - lamda1 * exp(tan(pi / 2.0 * (pow((angle_mix - angle_range_low[k]) / (angle_range_mid[k] - angle_range_low[k]),
				mu1) - 1.0)));
			//printf("mid->%lf->%lf->%lf\n",angle_mix - angle_range_low[k],angle_range_mid[k] - angle_range_low[k],prob_angle1);
		}
		else if (angle_mix > angle_range_mid[k] && angle_mix < angle_range_upp[k]) {
			prob_angle1 = 0 + lamda2 * exp(tan(pi / 2.0 * (pow((angle_range_upp[k] - angle_mix) / (angle_range_upp[k] - angle_range_mid[k]),
				mu2) - 1.0)));
			//printf("upp->%lf->%lf->%lf\n",angle_range_upp[k] - angle_mix,angle_range_upp[k] - angle_range_mid[k],prob_angle1);
		}
		else
			prob_angle1 = 0.0;
		//printf("%lf\t",prob_d);
		//printf("%lf\t",prob_angle1);
		angle_mix = tilt / delta2[k];
		if (angle_mix <= angle_range_low[k])
			prob_angle2 = 1.0;
		else if (angle_mix > angle_range_low[k] && angle_mix <= angle_range_mid[k]) {
			prob_angle2 = 1 - lamda1 * exp(tan(pi / 2.0 * (pow((angle_mix - angle_range_low[k]) / (angle_range_mid[k] - angle_range_low[k]),
				mu1) - 1.0)));
			//printf("mid->%lf->%lf->%lf\n",angle_mix - angle_range_low[k],angle_range_mid[k] - angle_range_low[k],prob_angle2);
		}
		else if (angle_mix > angle_range_mid[k] && angle_mix < angle_range_upp[k]) {
			prob_angle2 = 0 + lamda2 * exp(tan(pi / 2.0 * (pow((angle_range_upp[k] - angle_mix) / (angle_range_upp[k] - angle_range_mid[k]),
				mu2) - 1.0)));
			//printf("upp->%lf->%lf->%lf\n",angle_range_upp[k] - angle_mix,angle_range_upp[k] - angle_range_mid[k],prob_angle2);
		}
		else
			prob_angle2 = 0.0;
		//printf("%lf\t",prob_d);
		//printf("%lf\t",prob_angle2);
		return (prob_d * prob_angle1 * prob_angle2);
	}
	else {
		return 0.0;
	}
}
static void Qoc(double* a)
{
	int i, j, k;
	double m;
	for (i = 0; i < lon; i++) {
		for (j = 0; j < wid; j++) {
			m = 1.0;
			if (map[i][j] >= height_max) {
				qoc[i][j] = 0;
				continue;
			}
			for (k = 0; k < n_sensor_URBAN; k++) {  //¡À??¡¥2
				if (!avaiStatus_sense[k]) continue;
				m *= (1 + ga * Oq((int)(a[k * UNIT_URBAN + X]), (int)(a[k * UNIT_URBAN + Y]), i, j, a[k * UNIT_URBAN + PAN],
					a[k * UNIT_URBAN + TILT], k));
			}
			m = (m - 1) / ga;
			if (m > oq_beta) {
				m = 1;
			}
			else {
				m = 0.0;
			}
			qoc[i][j] = m; //printf("%f\n",qoc[i][j]);
		}
	}
	//for(i=0;i<lon/2;i++)
	//{
	//  for(j=0;j<wid/2;j++)
	//  {
	//      printf("%1.1f ",qoc[i][j]);
	//  }
	//printf("\n");
	//}
}
static double Cover(double* a)//?????2???¨ºcover
{
	int i, j;
	double m = 0.0;
	Qoc(a);
	for (i = 0; i < lon; i++)
		for (j = 0; j < wid; j++) {
			m += qoc[i][j];
		}
	return (m / nFreePoint);
}
static int Connectivity(double* a)
{
	int connect = 0;
	int i, j;
	//double di;
	int count = 0;
	for (i = 0; i < n_sensor_URBAN; i++) {
		for (j = 0; j < n_relay_URBAN; j++) {
			if (!avaiStatus_sense[i] || !avaiStatus_relay[j]) {
				allPathLoss_s_r[i][j] = INF_DOUBLE_HDSN_URBAN;
			}
			else {
				int p1_X = (int)(pos3D_DIREC[i][X]);
				int p1_Y = (int)(pos3D_DIREC[i][Y]);
				int p2_X = (int)(pos3D_RELAY[j][X]);
				int p2_Y = (int)(pos3D_RELAY[j][Y]);
				double tmpPL1 = PropaPathLoss(p1_X, p1_Y, map[p1_X][p1_Y], p2_X, p2_Y, map[p2_X][p2_Y]);
				double tmpPL2 = 0;// PropaPathLoss(p2_X, p2_Y, map[p2_X][p2_Y], p1_X, p1_Y, map[p1_X][p1_Y]);
				allPathLoss_s_r[i][j] = (tmpPL1 > tmpPL2 ? tmpPL1 : tmpPL2);
			}
		}
	}
	for (i = 0; i < n_sensor_URBAN; i++) {
		for (j = 0; j < n_relay_URBAN; j++) {
			if (allPathLoss_s_r[i][j] < th_PL) {
				connectstatus_sensor_relay[i][j] = 1;
			}
			else
				connectstatus_sensor_relay[i][j] = 0;
		}
	}
	for (i = 0; i < n_relay_URBAN; i++) {
		for (j = 0; j < n_relay_URBAN; j++) {
			if (!avaiStatus_relay[i] || !avaiStatus_relay[j] || i == j) {
				allPathLoss_r_r[i][j] = INF_DOUBLE_HDSN_URBAN;
			}
			else {
				int p1_X = (int)(pos3D_RELAY[i][X]);
				int p1_Y = (int)(pos3D_RELAY[i][Y]);
				int p2_X = (int)(pos3D_RELAY[j][X]);
				int p2_Y = (int)(pos3D_RELAY[j][Y]);
				double tmpPL1 = PropaPathLoss(p1_X, p1_Y, map[p1_X][p1_Y], p2_X, p2_Y, map[p2_X][p2_Y]);
				double tmpPL2 = 0;// PropaPathLoss(p2_X, p2_Y, map[p2_X][p2_Y], p1_X, p1_Y, map[p1_X][p1_Y]);
				allPathLoss_r_r[i][j] = //allPathLoss_r_r[j][i] =
					(tmpPL1 > tmpPL2 ? tmpPL1 : tmpPL2);
			}
		}
	}
	for (i = 0; i < n_relay_URBAN; i++) {
		for (j = 0; j < n_relay_URBAN; j++) {
			if (allPathLoss_r_r[i][j] < th_PL_relay) {
				connectstatus_relay_relay[i][j] = 1;
			}
			else {
				connectstatus_relay_relay[i][j] = 0;
			}
		}
	}
	//depth-first traverse
	int flag[n_relay_URBAN];
	int checked[n_relay_URBAN];
	for (i = 0; i < n_relay_URBAN; i++) flag[i] = 0;
	int status;
	int loop = 1;
	// int cur_loop;
	int pivot;
	for (i = 0; i < n_relay_URBAN; i++) {
		if (flag[i] == 0) {
			count = 1;
			status = 1;
			flag[i] = loop;
			pivot = i;
			for (j = 0; j < n_relay_URBAN; j++) checked[j] = 0;
			while (status) {
				checked[pivot] = 1;//visited
				for (j = 0; j < n_relay_URBAN; j++) {
					if (flag[j] == 0 &&
						connectstatus_relay_relay[pivot][j] &&
						connectstatus_relay_relay[j][pivot]) {
						flag[j] = loop;
						count++;
					}
				}
				status = 0;
				for (j = 0; j < n_relay_URBAN; j++)
					if (flag[j] == loop && checked[j] == 0) { //unvisited
						pivot = j;
						status = 1;
						break;
					}
			}
			if (count > connect) {
				connect = count;
				// cur_loop = loop;
			}
			loop++;
		}
	}
	return (connect);
}
static int CountObstacles(int i, int j, double h1, int a, int b, double h2, int* ind)
{
	double h = h1;
	double cc = h2;
	int m;
	int x, y, x1, y1;
	double z1, z2,
		z;  //z?????¡À??¨¦?¦Ì????¨¨   x?¡éy?a¨¢?¦Ì?o¨¢¡ÁY¡Á?¡À¨º2?¡ê¡§?y??¨ºy¡ê? x1?a¦Ì£¤??2?¨¢?¡ê¡§¡ä?¡¤?o?¡ê? z1?¡éz2¦Ì?D?¦Ì?¡Á?¡À¨º¦Ì????¨¨
	double k, k1;          //¨¢?¦Ì?3¨¦??¦Ì?D¡À?¨º
	double x2;            //¨®?¨®¨²¡ä?¡ä¡é?¨´?¨®¦Ì?¡Á?¡À¨º
	double y2;
	int x3;
	int y3;             //??y2??D??¡¥
	int countSwitch = 0;//ÕÏ°­ÎïÊýÄ¿
	int curStatus = -1;//ÊÇ·ñÔÚÕÏ°­ÎïÖÐ
	// -1: initialization
	//  0: not blocked
	//  1: blocked
	x = abs(a - i);    //¨¢?¦Ì???¦Ì?¡Á?¡À¨º2?
	y = abs(b - j);
	if (x >= y) {
		if (i != a) {
			x1 = (a - i) / x;         //¡ä??y?o¨ºy
			k = ((double)(b - j)) / ((double)(a - i));
			k1 = ((double)(cc - h)) / (a - i);
			for (m = 1; m < x; m++) {
				x2 = i + x1 * m;
				y2 = k * (x2 - i) + j;
				z = k1 * (x2 - i) + h; ////x?¡éy?¡éz¡Á?¡À¨º¡ê¡§?¡À??¡ê?
				if (y2 == (int)y2) {
					x3 = (int)x2;
					y3 = (int)y2;
					z1 = map[x3][y3];
				}
				else {
					x3 = (int)x2;
					y3 = (int)y2;
					z1 = map[x3][y3];
					y3 = y3 + 1;
					z2 = map[x3][y3];
					if (z1 < z2) z1 = z2;
				}
				if (z < z1) { //¸ÕÅöµ½»ò´¦ÓÚÕÏ°­Îï
					if (curStatus < 1) { //¸ÕÅöµ½
						curStatus = 1;//¼ÇÂ¼
						if (z1 >= height_max) //½¨ÖþÎï
							ind[countSwitch++] = 1;
						else//µØÃæÆð·ü
							ind[countSwitch++] = 0;
					}
					else if (z1 >= height_max)  //´ÓµØÃæÆð·ü×´Ì¬ÓÖÓöµ½½¨ÖþÎï£¬¼ÇÎª½¨ÖþÎï
						ind[countSwitch - 1] = 1;
				}
				else { //ÔÚ¿ÕÖÐ
					if (curStatus == 1)  //×ª»»
						curStatus = 0;
				}
			}
		}
	}
	else {
		if (j != b) {
			y1 = (b - j) / y;         //¡ä??y?o¨ºy
			k = ((double)(a - i)) / ((double)(b - j));
			k1 = ((double)(cc - h)) / (b - j);
			for (m = 1; m < y; m++) {
				y2 = j + y1 * m;
				x2 = k * (y2 - j) + i;
				z = k1 * (y2 - j) + h;
				if (x2 == (int)x2) {
					x3 = (int)x2;
					y3 = (int)y2;
					z1 = map[x3][y3];
				}
				else {
					x3 = (int)x2;
					y3 = (int)y2;
					z1 = map[x3][y3];
					x3 = x3 + 1;
					z2 = map[x3][y3];
					if (z1 < z2) z1 = z2;
				}
				if (z < z1) {
					if (curStatus < 1) {
						curStatus = 1;
						if (z1 >= height_max)
							ind[countSwitch++] = 1;
						else
							ind[countSwitch++] = 0;
					}
					else if (z1 >= height_max)
						ind[countSwitch - 1] = 1;
				}
				else {
					if (curStatus == 1)
						curStatus = 0;
				}
			}
		}
	}
	return (countSwitch);
}
static double PathLossOne(int i, int j, double h1, int a, int b, double h2, double di)
{
	double curPL;
	double d;
	int n;
	int nObst1;
	int ind1[max_obst];
	// int nObst2;
	//int ind2[max_obst];
	double PL1 = 0.0;
	// double PL2 = 0.0;
	if (di < 0.0) {
		d = resolution * rangeD(i, j, h1, a, b, h2);
	}
	else {
		d = resolution * di;
	}
	if (d > 1.0)
		curPL = 10.0 * n_PL * log10(d);
	else
		curPL = 0.0;
	nObst1 = CountObstacles(i, j, h1, a, b, h2, ind1);
	// nObst2 = 0;// CountObstacles(a, b, h2, i, j, h1, ind2);
	//if (nObst1 != nObst2) printf("The number of obstacles are not the same!\n\n\n\n\n\n\n\n");
	for (n = 0; n < nObst1; n++) {
		PL1 += l_PL[ind1[n]] * pow(a_PL, n);
	}
	//for (n = 0; n < nObst2; n++) {
	//  PL2 += l_PL[ind2[n]] * pow(a_PL, n);
	//}
	//printf("%d %d %d %d %lf\n", i, j, a, b, curPL);
	//printf("%d %d %d %d %d %lf\n", i, j, a, b, nObst1, PL1);
	//printf("%d %d %d %d %d %lf\n", a, b, i, j, nObst2, PL2);
	//if (PL1 > PL2) curPL += PL1;
	//else           curPL += PL2;
	curPL += PL1;
	return curPL;
}
// static double ConnectivityQuality(double* a)
// {
//     double sumCD = 0.0;
//     double sumPL = 0.0;
//     int i, j;
//     double curCD;
//     for (i = 0; i < n_sensor_URBAN; i++) {
//         if (!avaiStatus_sense[i]) continue;
//         curCD = 0;
//         for (j = 0; j < n_sensor_URBAN; j++) {
//             if (i == j) continue;
//             if (!avaiStatus_sense[j]) continue;
//             if (connectstatus_sensor_relay[i][j]) {
//                 curCD++;
//                 sumPL += allPathLoss_s_r[i][j];
//             }
//         }
//         sumCD += curCD;
//     }
//     double f1 = (n_sensor_URBAN - sumCD / n_sensor_URBAN) / n_sensor_URBAN;
//     double f2 = sumPL / sumCD / th_PL;
//     double w1 = 0.5, w2 = 0.5;
//     return (w1 * f1 + w2 * f2 + w1 * w2 * f1 * f2);
// }
void Fitness_HDSN_URBAN(double* individual, double* fitness, double* constrainV, int nx, int M)
{
	int unavail_sensor_num = 0;
	for (int i = 0; i < n_sensor_URBAN; i++) {
		pos3D_DIREC[i][X] = (int)(individual[i * UNIT_URBAN + X]);
		pos3D_DIREC[i][Y] = (int)(individual[i * UNIT_URBAN + Y]);
		pos3D_DIREC[i][Z] = map[(int)(individual[i * UNIT_URBAN + X])][(int)(individual[i * UNIT_URBAN + Y])];
		if (pos3D_DIREC[i][Z] >= height_max) {
			avaiStatus_sense[i] = 0;
			unavail_sensor_num++;
		}
		else {
			avaiStatus_sense[i] = 1;
		}
	}
	int offset = n_sensor_URBAN * UNIT_URBAN;
	for (int i = 0; i < n_relay_URBAN; i++) {
		pos3D_RELAY[i][X] = (int)(individual[offset + i * UNIT_relay_URBAN + X]);
		pos3D_RELAY[i][Y] = (int)(individual[offset + i * UNIT_relay_URBAN + Y]);
		pos3D_RELAY[i][Z] = map[(int)(individual[offset + i * UNIT_relay_URBAN + X])][(int)(individual[offset + i * UNIT_relay_URBAN +
			Y])];
		if (pos3D_RELAY[i][Z] >= height_max) {
			avaiStatus_relay[i] = 0;
		}
		else {
			avaiStatus_relay[i] = 1;
		}
	}
	int sizeConnect = Connectivity(individual);
	double f2 = Lifetime();
	////////////////////////////////////////
	////////////////////////////////////////
	////////////////////////////////////////
	double sumCD1 = 0.0;
	double sumPL1 = 0.0;
	double sumCD2 = 0.0;
	double sumPL2 = 0.0;
	int sumP = 0;
	int i, j, k;
	double curCD;
	double curPL;
	double tmp_PL[n_relay_URBAN];
	for (i = 0; i < n_sensor_URBAN; i++) {
		curCD = 0;
		curPL = 0;
		for (j = 0; j < n_relay_URBAN; j++) {
			if (connectstatus_sensor_relay[i][j]) {
				tmp_PL[j] = allPathLoss_s_r[i][j];
			}
			else {
				tmp_PL[j] = INF_DOUBLE_HDSN_URBAN;
			}
		}
		for (j = 0; j < TH_NNEI; j++) {
			for (k = j + 1; k < n_relay_URBAN; k++) {
				if (tmp_PL[j] > tmp_PL[k]) {
					double tmp = tmp_PL[j];
					tmp_PL[j] = tmp_PL[k];
					tmp_PL[k] = tmp;
				}
			}
			if (tmp_PL[j] < INF_DOUBLE_HDSN_URBAN) {
				curCD++;
				curPL += tmp_PL[j];
			}
		}
		sumCD1 += curCD;
		sumPL1 += curPL;
		if (curCD < TH_NNEI)
			sumP += (int)(TH_NNEI - curCD);
	}
	for (i = 0; i < n_relay_URBAN - 1; i++) {
		int ID_fr = ID_RELAY_HDSN_URBAN[i];
		curCD = 0;
		curPL = 0;
		for (j = 0; j < n_relay_URBAN; j++) {
			int ID_to = ID_RELAY_HDSN_URBAN[j];
			if (i >= j) {
				tmp_PL[ID_to] = INF_DOUBLE_HDSN_URBAN;
				continue;
			}
			if (connectstatus_relay_relay[ID_fr][ID_to]) {
				tmp_PL[ID_to] = allPathLoss_r_r[ID_fr][ID_to];
			}
			else {
				tmp_PL[ID_to] = INF_DOUBLE_HDSN_URBAN;
			}
		}
		int the_num = n_relay_URBAN - 1 - i;
		if (the_num > TH_NNEI) the_num = TH_NNEI;
		for (j = 0; j < the_num; j++) {
			for (k = j + 1; k < n_relay_URBAN; k++) {
				if (tmp_PL[j] > tmp_PL[k]) {
					double tmp = tmp_PL[j];
					tmp_PL[j] = tmp_PL[k];
					tmp_PL[k] = tmp;
				}
			}
			if (tmp_PL[j] < INF_DOUBLE_HDSN_URBAN) {
				curCD++;
				curPL += tmp_PL[j];
			}
		}
		sumCD2 += curCD;
		sumPL2 += curPL;
		if (curCD < the_num)
			sumP += (int)(the_num - curCD);
	}
	int penalty_sink = 0;
	if (pathloss2sink[n_relay_URBAN - 1] >= th_PL_relay) {
		penalty_sink = 1;
	}

	double f1 = 0.5 * (sumPL1 / sumCD1 / th_PL + sumPL2 / sumCD2 / th_PL_relay);
	//double f2 = (ds_URBAN - sumCD / ds_URBAN) / ds_URBAN;
	/////////////////////////////////////
	fitness[0] = 1.0 - Cover(individual) + (n_relay_URBAN - sizeConnect + sumP + unavail_sensor_num + penalty_sink) * penalty;
	fitness[1] = f1 + (n_relay_URBAN - sizeConnect + sumP + unavail_sensor_num + penalty_sink) * penalty;
	fitness[2] = f2 + (n_relay_URBAN - sizeConnect + sumP + unavail_sensor_num + penalty_sink) * penalty;
	return;
}
void Fitness_HDSN_URBAN_old(double* individual, double* fitness, double* constrainV, int nx, int M)
{
	int unavail_sensor_num = 0;
	for (int i = 0; i < n_sensor_URBAN; i++) {
		pos3D_DIREC[i][X] = (int)(individual[i * UNIT_URBAN + X]);
		pos3D_DIREC[i][Y] = (int)(individual[i * UNIT_URBAN + Y]);
		pos3D_DIREC[i][Z] = map[(int)(individual[i * UNIT_URBAN + X])][(int)(individual[i * UNIT_URBAN + Y])];
		if (pos3D_DIREC[i][Z] >= height_max) {
			avaiStatus_sense[i] = 0;
			unavail_sensor_num++;
		}
		else {
			avaiStatus_sense[i] = 1;
		}
	}
	int offset = n_sensor_URBAN * UNIT_URBAN;
	for (int i = 0; i < n_relay_URBAN; i++) {
		pos3D_RELAY[i][X] = (int)(individual[offset + i * UNIT_relay_URBAN + X]);
		pos3D_RELAY[i][Y] = (int)(individual[offset + i * UNIT_relay_URBAN + Y]);
		pos3D_RELAY[i][Z] = map[(int)(individual[offset + i * UNIT_relay_URBAN + X])][(int)(individual[offset + i * UNIT_relay_URBAN +
			Y])];
		if (pos3D_RELAY[i][Z] >= height_max) {
			avaiStatus_relay[i] = 0;
		}
		else {
			avaiStatus_relay[i] = 1;
		}
	}
	int sizeConnect = Connectivity(individual);
	////////////////////////////////////////
	double sumCD1 = 0.0;
	double sumPL1 = 0.0;
	double sumCD2 = 0.0;
	double sumPL2 = 0.0;
	int sumP = 0;
	int i, j, k;
	double curCD;
	double curPL;
	double tmp_PL[n_relay_URBAN];
	for (i = 0; i < n_sensor_URBAN; i++) {
		curCD = 0;
		curPL = 0;
		for (j = 0; j < n_relay_URBAN; j++) {
			if (connectstatus_sensor_relay[i][j]) {
				tmp_PL[j] = allPathLoss_s_r[i][j];
			}
			else {
				tmp_PL[j] = INF_DOUBLE_HDSN_URBAN;
			}
		}
		for (j = 0; j < TH_NNEI; j++) {
			for (k = j + 1; k < n_relay_URBAN; k++) {
				if (tmp_PL[j] > tmp_PL[k]) {
					double tmp = tmp_PL[j];
					tmp_PL[j] = tmp_PL[k];
					tmp_PL[k] = tmp;
				}
			}
			if (tmp_PL[j] < INF_DOUBLE_HDSN_URBAN) {
				curCD++;
				curPL += tmp_PL[j];
			}
		}
		sumCD1 += curCD;
		sumPL1 += curPL;
		if (curCD < TH_NNEI)
			sumP += (int)(TH_NNEI - curCD);
	}
	for (i = 0; i < n_relay_URBAN; i++) {
		curCD = 0;
		curPL = 0;
		for (j = 0; j < n_relay_URBAN; j++) {
			if (connectstatus_relay_relay[i][j]) {
				tmp_PL[j] = allPathLoss_r_r[i][j];
			}
			else {
				tmp_PL[j] = INF_DOUBLE_HDSN_URBAN;
			}
		}
		for (j = 0; j < TH_NNEI; j++) {
			for (k = j + 1; k < n_relay_URBAN; k++) {
				if (tmp_PL[j] > tmp_PL[k]) {
					double tmp = tmp_PL[j];
					tmp_PL[j] = tmp_PL[k];
					tmp_PL[k] = tmp;
				}
			}
			if (tmp_PL[j] < INF_DOUBLE_HDSN_URBAN) {
				curCD++;
				curPL += tmp_PL[j];
			}
		}
		sumCD2 += curCD;
		sumPL2 += curPL;
		if (curCD < TH_NNEI)
			sumP += (int)(TH_NNEI - curCD);
	}
	double f1 = 0.5 * (sumPL1 / sumCD1 / th_PL + sumPL2 / sumCD2 / th_PL_relay);
	//double f2 = (ds_URBAN - sumCD / ds_URBAN) / ds_URBAN;
	double f2 = Lifetime();
	/////////////////////////////////////
	fitness[0] = 1.0 - Cover(individual) + (n_relay_URBAN - sizeConnect + sumP + unavail_sensor_num) * penalty;
	fitness[1] = f1 + (n_relay_URBAN - sizeConnect + sumP + unavail_sensor_num) * penalty;
	fitness[2] = f2 + (n_relay_URBAN - sizeConnect + sumP + unavail_sensor_num) * penalty;
	return;
}
static double ArcPan(int i, int j, int a, int b)
{
	double temp;
	if (j == b) {
		if (a > i)
			return 0.0;
		else if (a < i)
			return pi;
	}
	temp = (a - i) / sqrt((double)(a - i) * (a - i) + (b - j) * (b - j));
	if (j > b)
		return 2 * pi - acos(temp);
	else
		return acos(temp);
}
static double ArcTilt(int i, int j, int a, int b)
{
	double temp;
	double hs, hp;
	hs = map[i][j];
	hp = map[a][b];
	if (hs == hp)  //¡¤¦Ì?????¨¨0
		return 0.0;
	temp = sqrt((double)(a - i) * (a - i) + (b - j) * (b - j)) /
		sqrt((double)(a - i) * (a - i) + (b - j) * (b - j) + (hp - hs) * (hp - hs)); //?¨®¨®¨¤?¨°
	if (hs > hp)
		return -acos(temp);
	else
		return acos(temp);
}
// static double myErf(double a)//a>0¨º¡ÀmyErf(a)>0 (myErf/2)
// {
//     int i, j;
//     double step, step_number, sum, t, temp;
//     if (a < 0) {
//         j = -1;
//         a = -a;
//     } else
//         j = 1;
//     step_number = 10; //²½Êý
//     step = a / step_number; //²½³¤
//     sum = 0.0;
//     for (i = 0; i < step_number; i++) {
//         t = (i + 0.5) * step;
//         temp = exp(-t * t) * step;
//         if (temp < 0.000001)
//             break;
//         sum += temp;
//     }
//     return j * (2.0 / sqrtPI) * sum;
// }
//¿¼ÂÇÖ±ÏßÓë·´Éä´«²¥µÄÂ·¾¶ËðºÄ
static double PropaPathLoss(int i, int j, double h1, int a, int b, double h2)
{
	//¶ÓÁÐ
	prop_ind_start = 0;
	prop_ind_final = 0;
	//Ö±´ïËðºÄ
	double minPathLoss = PathLossOne(i, j, h1, a, b, h2, -1);
	int recTag;
	//³õÊ¼»¯£¬½«·¢ÉäµãÖÜÎ§µÄ·´ÉäÎï¼ÓÈë¶ÓÁÐ
	for (int n = 0; n < mirror_num; n++) {
		recTag = 0;
		switch (flag_getAngle) {
		case 0:
			//recTag = getAngleRange(i, j, h1, -1, -1, prop_ind_final, n,
			//  i, j, h1, a, b, h2);
			//break;
		case 1:
			recTag = getAngleRange1(i, j, h1, -1, -1, prop_ind_final, n,
				i, j, h1, a, b, h2);
			break;
		default:
			printf("%s(line %d): flag_getAngle ERROR, exiting...\n", __FILE__, __LINE__);
			exit(99);
			break;
		}
		//ÐèÒª¼ÇÂ¼£¬ÓàÏÂÐÅÏ¢
		if (recTag) {
			prop_mirror_ind[prop_ind_final] = n;
			prop_ind_parent[prop_ind_final] = -1;
			prop_num_reflection[prop_ind_final] = 0;
			prop_ind_final++;
		}
	}
	//¸÷¸öµã
	double from_p_X, from_p_Y, from_p_Z;
	double to_p_X, to_p_Y, to_p_Z;
	double inter_p_X, inter_p_Y, inter_p_Z;
	//¸÷¸ö±êÇ©
	int freespaceTag;
	int interSecTag;
	int parentInd;
	int cur_mirrorInd;
	prop_tmp_PL[0] = minPathLoss;
	//±éÀú¶ÓÁÐ
	while (prop_ind_start < prop_ind_final) {
		prop_tmp_PL[prop_ind_start + 1] = INF_DOUBLE_HDSN_URBAN;
		freespaceTag = 1;
		cur_mirrorInd = prop_mirror_ind[prop_ind_start];
		//Ä¿µÄµã
		to_p_X = a;
		to_p_Y = b;
		to_p_Z = h2;
		//ÐéÄâ·¢Éäµã
		from_p_X = prop_X[prop_ind_start];
		from_p_Y = prop_Y[prop_ind_start];
		from_p_Z = prop_Z[prop_ind_start];
		//ÐéÄâ·¢ÉäµãÓëÄ¿µÄµãµÄÁ¬ÏßºÍ·´ÉäÃæµÄ½»µã
		interSecTag = detectIntersection(from_p_X, from_p_Y, from_p_Z,
			to_p_X, to_p_Y, to_p_Z,
			inter_p_X, inter_p_Y, inter_p_Z,
			prop_mirror_ind[prop_ind_start]);
		//´ÓÄÄ·´Éä¹ýÀ´£¬ÉÏÒ»¸ö·´ÉäÃæ
		parentInd = prop_ind_parent[prop_ind_start];
		//ÅÐ¶Ï×îºóÒ»´Î·´ÉäÖ®Ç°£¬ÐÅºÅÊÇ·ñ±»×è¶Ï
		while (interSecTag && freespaceTag && parentInd >= 0) {
			cur_mirrorInd = prop_mirror_ind[parentInd];
			//½»µãÊÇÔÝÊ±µÄÄ¿µÄµã
			to_p_X = inter_p_X;
			to_p_Y = inter_p_Y;
			to_p_Z = inter_p_Z;
			//ÐéÄâ·¢Éäµã
			from_p_X = prop_X[parentInd];
			from_p_Y = prop_Y[parentInd];
			from_p_Z = prop_Z[parentInd];
			//ÔÚµ±Ç°·´ÉäÃæµÄÐÂ½»µã
			interSecTag = detectIntersection(from_p_X, from_p_Y, from_p_Z,
				to_p_X, to_p_Y, to_p_Z,
				inter_p_X, inter_p_Y, inter_p_Z,
				cur_mirrorInd);
			if (interSecTag)
				freespaceTag = LOS_double(inter_p_X, inter_p_Y, inter_p_Z, cur_mirrorInd,
					to_p_X, to_p_Y, to_p_Z, -1);
			//ÉÏÒ»¸ö·´ÉäÃæ
			parentInd = prop_ind_parent[parentInd];
		}
		//Î´±»×è¶Ï£¬ÇÒÐÅºÅÄÜ·´Éäµ½Ä¿±ê
		if (interSecTag && freespaceTag &&
			LOS_double(i, j, h1, -1, inter_p_X, inter_p_Y, inter_p_Z, cur_mirrorInd)) {
			//¼ÆËã¿¼ÂÇÕÏ°­ÎïµÄÂ·¾¶ËðºÄ£¬ÔÚ×îºóÒ»¸ö·´ÉäÃæ
			//Ä¿µÄµØ
			to_p_X = a;
			to_p_Y = b;
			to_p_Z = h2;
			//ÐéÄâ·¢Éäµã
			from_p_X = prop_X[prop_ind_start];
			from_p_Y = prop_Y[prop_ind_start];
			from_p_Z = prop_Z[prop_ind_start];
			//½»µã
			detectIntersection(from_p_X, from_p_Y, from_p_Z,
				to_p_X, to_p_Y, to_p_Z,
				inter_p_X, inter_p_Y, inter_p_Z,
				prop_mirror_ind[prop_ind_start]);
			//ÐéÄâµãÓëÄ¿µÄµãµÄ¾àÀë
			double di = rangeD((int)from_p_X, (int)from_p_Y, from_p_Z, (int)to_p_X, (int)to_p_Y, to_p_Z);
			//×ÜµÄÂ·¾¶ËðºÄ
			double tmpPathLoss = PathLossOne((int)inter_p_X, (int)inter_p_Y, inter_p_Z, (int)to_p_X, (int)to_p_Y, to_p_Z, di);
			//¼ÇÂ¼½ÏÐ¡ËðºÄ
			if (tmpPathLoss < minPathLoss) {
				minPathLoss = tmpPathLoss;
				//if (prop_num_reflection[prop_ind_start] > 0){
				//  int check = 1;
				//}
			}
			prop_tmp_PL[prop_ind_start + 1] = tmpPathLoss;
		}
		/*else */ {
			//ÓÉµ±Ç°·´ÉäÃæ£¬Ñ°ÕÒÏÂÒ»¸ö·´ÉäÃæ£¬¼ÓÈë¶ÓÁÐ
			for (int n = 0; n < mirror_num; n++) {
				if (prop_ind_final < MAX_PROPAGATION_ITER &&
					prop_num_reflection[prop_ind_start] < MAX_PROPAGATION_NUM_REFLECTION) {
					recTag = 0;
					switch (flag_getAngle) {
					case 0:
						//recTag = getAngleRange(prop_X[prop_ind_start], prop_Y[prop_ind_start], prop_Z[prop_ind_start],
						//  prop_ind_start, prop_mirror_ind[prop_ind_start],
						//  prop_ind_final, n,
						//  i, j, h1, a, b, h2);
						//break;
					case 1:
						recTag = getAngleRange1(prop_X[prop_ind_start], prop_Y[prop_ind_start], prop_Z[prop_ind_start],
							prop_ind_start, prop_mirror_ind[prop_ind_start],
							prop_ind_final, n,
							i, j, h1, a, b, h2);
						break;
					default:
						printf("%s(line %d): flag_getAngle ERROR, exiting...\n", __FILE__, __LINE__);
						exit(99);
						break;
					}
					if (recTag) {
						prop_mirror_ind[prop_ind_final] = n;
						prop_ind_parent[prop_ind_final] = prop_ind_start;
						prop_num_reflection[prop_ind_final] = prop_num_reflection[prop_ind_start] + 1;
						prop_ind_final++;
					}
				}
			}
		}
		//printf("%e ", minPathLoss);
		//¶ÓÁÐÏÂÒ»¸öÔªËØ
		prop_ind_start++;
	}
	//printf("\n%d --- %e\n", prop_ind_final, pre_PL - minPathLoss);
	//if (pre_PL - minPathLoss > 0){
	//  int tag = 0;
	//}
	//if (prop_ind_final >= 512){
	//  printf("MAX_PROPAGATION_ITER reached.\n");
	//}
	//printf("prop_ind_final = %d\n", prop_ind_final);
	//if (prop_ind_final > 256){
	//  printf("prop_ind_final = %d //////////////////////////////////////////////////////////////\n", prop_ind_final);
	//}
	//·µ»Ø×îÐ¡Â·¾¶ËðºÄ
	return minPathLoss;
}
// static int getAngleRange(double _fr_X, double _fr_Y, double _fr_Z,//
//                          int ind_prop_fr, int ind_mirror_fr,
//                          int ind_prop_to, int ind_mirror_to,
//                          int X_TX, int Y_TX, double Z_TX,
//                          int X_RX, int Y_RX, double Z_RX)
// {
//     int boundary_X_min;
//     int boundary_X_max;
//     int boundary_Y_min;
//     int boundary_Y_max;
//     if (X_TX < X_RX) {
//         boundary_X_min = X_TX;
//         boundary_X_max = X_RX;
//     } else {
//         boundary_X_min = X_RX;
//         boundary_X_max = X_TX;
//     }
//     if (Y_TX < Y_RX) {
//         boundary_Y_min = Y_TX;
//         boundary_Y_max = Y_RX;
//     } else {
//         boundary_Y_min = Y_RX;
//         boundary_Y_max = Y_TX;
//     }
//     //¸÷¸öµã
//     double from_p_X, from_p_Y, from_p_Z;
//     double to_p_X, to_p_Y, to_p_Z;
//     double inter_p_X, inter_p_Y, inter_p_Z;
//     double vir_to_X, vir_to_Y, vir_to_Z;
//     //¸÷¸ö±êÇ©
//     int freespaceTag;
//     int interSecTag;
//     if (ind_prop_fr < 0 || ind_mirror_fr < 0) {
//         int m_to_direct = mirror_direction[ind_mirror_to];
//         double m_to_pos_north = mirror_pos_north[ind_mirror_to];
//         double m_to_pos_east = mirror_pos_east[ind_mirror_to];
//         double m_to_pos_south = mirror_pos_south[ind_mirror_to];
//         double m_to_pos_west = mirror_pos_west[ind_mirror_to];
//         if ((m_to_pos_south < boundary_X_min || m_to_pos_north > boundary_X_max) &&
//                 (m_to_pos_west > boundary_Y_max || m_to_pos_east < boundary_Y_min)) {
//             return 0;
//         }
//         switch (m_to_direct) {
//         case direction_north:
//             if (_fr_X >= m_to_pos_north) {
//                 return 0;
//             }
//             vir_to_X = prop_X[ind_prop_to] = 2 * m_to_pos_north - _fr_X;
//             vir_to_Y = prop_Y[ind_prop_to] = _fr_Y;
//             vir_to_Z = prop_Z[ind_prop_to] = _fr_Z;
//             from_p_X = _fr_X;
//             from_p_Y = _fr_Y;
//             from_p_Z = _fr_Z;
//             to_p_X = m_to_pos_north;
//             to_p_Y = m_to_pos_west;
//             to_p_Z = Z_RX;
//             for (to_p_Y = m_to_pos_west;
//                     to_p_Y <= m_to_pos_east;
//                     to_p_Y++) {
//                 if (LOS_building_double(from_p_X, from_p_Y, from_p_Z, ind_mirror_fr,
//                                         to_p_X, to_p_Y, to_p_Z, ind_mirror_to))
//                     break;
//             }
//             if (to_p_Y <= m_to_pos_east) {
//                 int pre_Y = (int)to_p_Y;
//                 to_p_Y--;
//                 if (to_p_Y < m_to_pos_west)
//                     to_p_Y = m_to_pos_west;
//                 prop_angle_range[ind_prop_to][angle_ind_min] =
//                     atan((to_p_Y - vir_to_Y) /
//                          (vir_to_X - m_to_pos_north));
//                 for (to_p_Y = m_to_pos_east;
//                         to_p_Y > pre_Y;
//                         to_p_Y--) {
//                     if (LOS_building_double(from_p_X, from_p_Y, from_p_Z, ind_mirror_fr,
//                                             to_p_X, to_p_Y, to_p_Z, ind_mirror_to))
//                         break;
//                 }
//                 to_p_Y++;
//                 if (to_p_Y > m_to_pos_east)
//                     to_p_Y = m_to_pos_east;
//                 prop_angle_range[ind_prop_to][angle_ind_max] =
//                     atan((to_p_Y - vir_to_Y) /
//                          (vir_to_X - m_to_pos_north));
//                 return 1;
//             } else {
//                 return 0;
//             }
//             break;
//         case direction_east:
//             if (_fr_Y <= m_to_pos_east) {
//                 return 0;
//             }
//             vir_to_X = prop_X[ind_prop_to] = _fr_X;
//             vir_to_Y = prop_Y[ind_prop_to] = 2 * m_to_pos_east - _fr_Y;
//             vir_to_Z = prop_Z[ind_prop_to] = _fr_Z;
//             from_p_X = _fr_X;
//             from_p_Y = _fr_Y;
//             from_p_Z = _fr_Z;
//             to_p_X = m_to_pos_north;
//             to_p_Y = m_to_pos_east;
//             to_p_Z = Z_RX;
//             for (to_p_X = m_to_pos_north;
//                     to_p_X <= m_to_pos_south;
//                     to_p_X++) {
//                 if (LOS_building_double(from_p_X, from_p_Y, from_p_Z, ind_mirror_fr,
//                                         to_p_X, to_p_Y, to_p_Z, ind_mirror_to))
//                     break;
//             }
//             if (to_p_X <= m_to_pos_south) {
//                 int pre_X = (int)to_p_X;
//                 to_p_X--;
//                 if (to_p_X < m_to_pos_north)
//                     to_p_X = m_to_pos_north;
//                 prop_angle_range[ind_prop_to][angle_ind_min] =
//                     atan((to_p_X - vir_to_X) /
//                          (m_to_pos_east - vir_to_Y));
//                 for (to_p_X = m_to_pos_south;
//                         to_p_X > pre_X;
//                         to_p_X--) {
//                     if (LOS_building_double(from_p_X, from_p_Y, from_p_Z, ind_mirror_fr,
//                                             to_p_X, to_p_Y, to_p_Z, ind_mirror_to))
//                         break;
//                 }
//                 to_p_X++;
//                 if (to_p_X > m_to_pos_south)
//                     to_p_X = m_to_pos_south;
//                 prop_angle_range[ind_prop_to][angle_ind_max] =
//                     atan((to_p_X - vir_to_X) /
//                          (m_to_pos_east - vir_to_Y));
//                 return 1;
//             } else {
//                 return 0;
//             }
//             break;
//         case direction_south:
//             if (_fr_X <= m_to_pos_south) {
//                 return 0;
//             }
//             vir_to_X = prop_X[ind_prop_to] = 2 * m_to_pos_south - _fr_X;
//             vir_to_Y = prop_Y[ind_prop_to] = _fr_Y;
//             vir_to_Z = prop_Z[ind_prop_to] = _fr_Z;
//             from_p_X = _fr_X;
//             from_p_Y = _fr_Y;
//             from_p_Z = _fr_Z;
//             to_p_X = m_to_pos_south;
//             to_p_Y = m_to_pos_east;
//             to_p_Z = Z_RX;
//             for (to_p_Y = m_to_pos_east;
//                     to_p_Y >= m_to_pos_west;
//                     to_p_Y--) {
//                 if (LOS_building_double(from_p_X, from_p_Y, from_p_Z, ind_mirror_fr,
//                                         to_p_X, to_p_Y, to_p_Z, ind_mirror_to))
//                     break;
//             }
//             if (to_p_Y >= m_to_pos_west) {
//                 int pre_Y = (int)to_p_Y;
//                 to_p_Y++;
//                 if (to_p_Y > m_to_pos_east)
//                     to_p_Y = m_to_pos_east;
//                 prop_angle_range[ind_prop_to][angle_ind_min] =
//                     atan((vir_to_Y - to_p_Y) /
//                          (m_to_pos_south - vir_to_X));
//                 for (to_p_Y = m_to_pos_west;
//                         to_p_Y < pre_Y;
//                         to_p_Y++) {
//                     if (LOS_building_double(from_p_X, from_p_Y, from_p_Z, ind_mirror_fr,
//                                             to_p_X, to_p_Y, to_p_Z, ind_mirror_to))
//                         break;
//                 }
//                 to_p_Y--;
//                 if (to_p_Y < m_to_pos_west)
//                     to_p_Y = m_to_pos_west;
//                 prop_angle_range[ind_prop_to][angle_ind_max] =
//                     atan((vir_to_Y - to_p_Y) /
//                          (m_to_pos_south - vir_to_X));
//                 return 1;
//             } else {
//                 return 0;
//             }
//             break;
//         case direction_west:
//             if (_fr_Y >= m_to_pos_west) {
//                 return 0;
//             }
//             vir_to_X = prop_X[ind_prop_to] = _fr_X;
//             vir_to_Y = prop_Y[ind_prop_to] = 2 * m_to_pos_west - _fr_Y;
//             vir_to_Z = prop_Z[ind_prop_to] = _fr_Z;
//             from_p_X = _fr_X;
//             from_p_Y = _fr_Y;
//             from_p_Z = _fr_Z;
//             to_p_X = m_to_pos_south;
//             to_p_Y = m_to_pos_west;
//             to_p_Z = Z_RX;
//             for (to_p_X = m_to_pos_south;
//                     to_p_X >= m_to_pos_north;
//                     to_p_X--) {
//                 if (LOS_building_double(from_p_X, from_p_Y, from_p_Z, ind_mirror_fr,
//                                         to_p_X, to_p_Y, to_p_Z, ind_mirror_to))
//                     break;
//             }
//             if (to_p_X >= m_to_pos_north) {
//                 int pre_X = (int)to_p_X;
//                 to_p_X++;
//                 if (to_p_X > m_to_pos_south)
//                     to_p_X = m_to_pos_south;
//                 prop_angle_range[ind_prop_to][angle_ind_min] =
//                     atan((vir_to_X - to_p_X) /
//                          (vir_to_Y - m_to_pos_west));
//                 for (to_p_X = m_to_pos_north;
//                         to_p_X < pre_X;
//                         to_p_X++) {
//                     if (LOS_building_double(from_p_X, from_p_Y, from_p_Z, ind_mirror_fr,
//                                             to_p_X, to_p_Y, to_p_Z, ind_mirror_to))
//                         break;
//                 }
//                 to_p_X--;
//                 if (to_p_X < m_to_pos_north)
//                     to_p_X = m_to_pos_north;
//                 prop_angle_range[ind_prop_to][angle_ind_max] =
//                     atan((vir_to_X - to_p_X) /
//                          (vir_to_Y - m_to_pos_west));
//                 return 1;
//             } else {
//                 return 0;
//             }
//             break;
//         default:
//             printf("%s(line %d): MIRROR DIRECTION ERROR, exiting...\n", __FILE__, __LINE__);
//             exit(100);
//             break;
//         }
//     } else {
//         int m_fr_direct = mirror_direction[ind_mirror_fr];
//         double m_fr_pos_north = mirror_pos_north[ind_mirror_fr];
//         double m_fr_pos_east = mirror_pos_east[ind_mirror_fr];
//         double m_fr_pos_south = mirror_pos_south[ind_mirror_fr];
//         double m_fr_pos_west = mirror_pos_west[ind_mirror_fr];
//         int m_to_direct = mirror_direction[ind_mirror_to];
//         double m_to_pos_north = mirror_pos_north[ind_mirror_to];
//         double m_to_pos_east = mirror_pos_east[ind_mirror_to];
//         double m_to_pos_south = mirror_pos_south[ind_mirror_to];
//         double m_to_pos_west = mirror_pos_west[ind_mirror_to];
//         if ((m_to_pos_south < boundary_X_min || m_to_pos_north > boundary_X_max) &&
//                 (m_to_pos_west > boundary_Y_max || m_to_pos_east < boundary_Y_min)) {
//             return 0;
//         }
//         //printf("%s(line %d): getAngleRange ERROR, exiting...\n", __FILE__, __LINE__);
//         //exit(101);
//         //double tmp_angle_min1;
//         //double tmp_angle_max1;
//         //double tmp_angle_min2;
//         //double tmp_angle_max2;
//         //int pre_X;
//         //int pre_Y;
//         //int pre_Z;
//         // int direct_diff =
//         //     (m_fr_direct - m_to_direct + 4) % 4;
//         //switch (direct_diff){
//         //case 0:
//         //  return 0;
//         //  break;
//         //case 1:
//         //  tmp_angle_min1 = pi / 2.0
//         //      - prop_angle_range[ind_prop_fr][angle_ind_max];
//         //  tmp_angle_max1 = pi / 2.0
//         //      - prop_angle_range[ind_prop_fr][angle_ind_min];
//         //  break;
//         //case 2:
//         //  tmp_angle_min1 = 0.0
//         //      - prop_angle_range[ind_prop_fr][angle_ind_max];
//         //  tmp_angle_max1 = 0.0
//         //      - prop_angle_range[ind_prop_fr][angle_ind_min];
//         //  break;
//         //case 3:
//         //  tmp_angle_min1 = -pi / 2.0
//         //      - prop_angle_range[ind_prop_fr][angle_ind_max];
//         //  tmp_angle_max1 = -pi / 2.0
//         //      - prop_angle_range[ind_prop_fr][angle_ind_min];
//         //  break;
//         //default:
//         //  printf("%s(line %d): MIRROR DIRECTION ERROR, exiting...\n", __FILE__, __LINE__);
//         //  exit(100);
//         //  break;
//         //}
//         switch (m_to_direct) {
//         case direction_north:
//             if (m_to_direct == m_fr_direct ||
//                     _fr_X >= m_to_pos_north ||
//                     m_to_pos_north <= m_fr_pos_north) {
//                 return 0;
//             }
//             vir_to_X = prop_X[ind_prop_to] = 2 * m_to_pos_north - _fr_X;
//             vir_to_Y = prop_Y[ind_prop_to] = _fr_Y;
//             vir_to_Z = prop_Z[ind_prop_to] = _fr_Z;
//             from_p_X = _fr_X;
//             from_p_Y = _fr_Y;
//             from_p_Z = _fr_Z;
//             to_p_X = m_to_pos_north;
//             to_p_Y = m_to_pos_west;
//             to_p_Z = Z_RX;
//             for (to_p_Y = m_to_pos_west;
//                     to_p_Y <= m_to_pos_east;
//                     to_p_Y++) {
//                 interSecTag = detectIntersection(from_p_X, from_p_Y, from_p_Z,
//                                                  to_p_X, to_p_Y, to_p_Z,
//                                                  inter_p_X, inter_p_Y, inter_p_Z,
//                                                  ind_mirror_fr);
//                 if (interSecTag)
//                     freespaceTag = LOS_building_double(inter_p_X, inter_p_Y, inter_p_Z, ind_mirror_fr,
//                                                        to_p_X, to_p_Y, to_p_Z, ind_mirror_to);
//                 if (interSecTag && freespaceTag)
//                     break;
//             }
//             if (to_p_Y <= m_to_pos_east) {
//                 int pre_Y = (int)to_p_Y;
//                 to_p_Y--;
//                 if (to_p_Y < m_to_pos_west)
//                     to_p_Y = m_to_pos_west;
//                 prop_angle_range[ind_prop_to][angle_ind_min] =
//                     atan((to_p_Y - vir_to_Y) /
//                          (vir_to_X - m_to_pos_north));
//                 for (to_p_Y = m_to_pos_east;
//                         to_p_Y > pre_Y;
//                         to_p_Y--) {
//                     interSecTag = detectIntersection(from_p_X, from_p_Y, from_p_Z,
//                                                      to_p_X, to_p_Y, to_p_Z,
//                                                      inter_p_X, inter_p_Y, inter_p_Z,
//                                                      ind_mirror_fr);
//                     if (interSecTag)
//                         freespaceTag = LOS_building_double(inter_p_X, inter_p_Y, inter_p_Z, ind_mirror_fr,
//                                                            to_p_X, to_p_Y, to_p_Z, ind_mirror_to);
//                     if (interSecTag && freespaceTag)
//                         break;
//                 }
//                 to_p_Y++;
//                 if (to_p_Y > m_to_pos_east)
//                     to_p_Y = m_to_pos_east;
//                 prop_angle_range[ind_prop_to][angle_ind_max] =
//                     atan((to_p_Y - vir_to_Y) /
//                          (vir_to_X - m_to_pos_north));
//                 return 1;
//             } else {
//                 return 0;
//             }
//             break;
//         case direction_east:
//             if (m_to_direct == m_fr_direct ||
//                     _fr_Y <= m_to_pos_east ||
//                     m_to_pos_east >= m_fr_pos_east) {
//                 return 0;
//             }
//             vir_to_X = prop_X[ind_prop_to] = _fr_X;
//             vir_to_Y = prop_Y[ind_prop_to] = 2 * m_to_pos_east - _fr_Y;
//             vir_to_Z = prop_Z[ind_prop_to] = _fr_Z;
//             from_p_X = _fr_X;
//             from_p_Y = _fr_Y;
//             from_p_Z = _fr_Z;
//             to_p_X = m_to_pos_north;
//             to_p_Y = m_to_pos_east;
//             to_p_Z = Z_RX;
//             for (to_p_X = m_to_pos_north;
//                     to_p_X <= m_to_pos_south;
//                     to_p_X++) {
//                 interSecTag = detectIntersection(from_p_X, from_p_Y, from_p_Z,
//                                                  to_p_X, to_p_Y, to_p_Z,
//                                                  inter_p_X, inter_p_Y, inter_p_Z,
//                                                  ind_mirror_fr);
//                 if (interSecTag)
//                     freespaceTag = LOS_building_double(inter_p_X, inter_p_Y, inter_p_Z, ind_mirror_fr,
//                                                        to_p_X, to_p_Y, to_p_Z, ind_mirror_to);
//                 if (interSecTag && freespaceTag)
//                     break;
//             }
//             if (to_p_X <= m_to_pos_south) {
//                 int pre_X = (int)to_p_X;
//                 to_p_X--;
//                 if (to_p_X < m_to_pos_north)
//                     to_p_X = m_to_pos_north;
//                 prop_angle_range[ind_prop_to][angle_ind_min] =
//                     atan((to_p_X - vir_to_X) /
//                          (m_to_pos_east - vir_to_Y));
//                 for (to_p_X = m_to_pos_south;
//                         to_p_X > pre_X;
//                         to_p_X--) {
//                     interSecTag = detectIntersection(from_p_X, from_p_Y, from_p_Z,
//                                                      to_p_X, to_p_Y, to_p_Z,
//                                                      inter_p_X, inter_p_Y, inter_p_Z,
//                                                      ind_mirror_fr);
//                     if (interSecTag)
//                         freespaceTag = LOS_building_double(inter_p_X, inter_p_Y, inter_p_Z, ind_mirror_fr,
//                                                            to_p_X, to_p_Y, to_p_Z, ind_mirror_to);
//                     if (interSecTag && freespaceTag)
//                         break;
//                 }
//                 to_p_X++;
//                 if (to_p_X > m_to_pos_south)
//                     to_p_X = m_to_pos_south;
//                 prop_angle_range[ind_prop_to][angle_ind_max] =
//                     atan((to_p_X - vir_to_X) /
//                          (m_to_pos_east - vir_to_Y));
//                 return 1;
//             } else {
//                 return 0;
//             }
//             break;
//         case direction_south:
//             if (m_to_direct == m_fr_direct ||
//                     _fr_X <= m_to_pos_south ||
//                     m_to_pos_south >= m_fr_pos_south) {
//                 return 0;
//             }
//             vir_to_X = prop_X[ind_prop_to] = 2 * m_to_pos_south - _fr_X;
//             vir_to_Y = prop_Y[ind_prop_to] = _fr_Y;
//             vir_to_Z = prop_Z[ind_prop_to] = _fr_Z;
//             from_p_X = _fr_X;
//             from_p_Y = _fr_Y;
//             from_p_Z = _fr_Z;
//             to_p_X = m_to_pos_south;
//             to_p_Y = m_to_pos_east;
//             to_p_Z = Z_RX;
//             for (to_p_Y = m_to_pos_east;
//                     to_p_Y >= m_to_pos_west;
//                     to_p_Y--) {
//                 interSecTag = detectIntersection(from_p_X, from_p_Y, from_p_Z,
//                                                  to_p_X, to_p_Y, to_p_Z,
//                                                  inter_p_X, inter_p_Y, inter_p_Z,
//                                                  ind_mirror_fr);
//                 if (interSecTag)
//                     freespaceTag = LOS_building_double(inter_p_X, inter_p_Y, inter_p_Z, ind_mirror_fr,
//                                                        to_p_X, to_p_Y, to_p_Z, ind_mirror_to);
//                 if (interSecTag && freespaceTag)
//                     break;
//             }
//             if (to_p_Y >= m_to_pos_west) {
//                 int pre_Y = (int)to_p_Y;
//                 to_p_Y++;
//                 if (to_p_Y > m_to_pos_east)
//                     to_p_Y = m_to_pos_east;
//                 prop_angle_range[ind_prop_to][angle_ind_min] =
//                     atan((vir_to_Y - to_p_Y) /
//                          (m_to_pos_south - vir_to_X));
//                 for (to_p_Y = m_to_pos_west;
//                         to_p_Y < pre_Y;
//                         to_p_Y++) {
//                     interSecTag = detectIntersection(from_p_X, from_p_Y, from_p_Z,
//                                                      to_p_X, to_p_Y, to_p_Z,
//                                                      inter_p_X, inter_p_Y, inter_p_Z,
//                                                      ind_mirror_fr);
//                     if (interSecTag)
//                         freespaceTag = LOS_building_double(inter_p_X, inter_p_Y, inter_p_Z, ind_mirror_fr,
//                                                            to_p_X, to_p_Y, to_p_Z, ind_mirror_to);
//                     if (interSecTag && freespaceTag)
//                         break;
//                 }
//                 to_p_Y--;
//                 if (to_p_Y < m_to_pos_west)
//                     to_p_Y = m_to_pos_west;
//                 prop_angle_range[ind_prop_to][angle_ind_max] =
//                     atan((vir_to_Y - to_p_Y) /
//                          (m_to_pos_south - vir_to_X));
//                 return 1;
//             } else {
//                 return 0;
//             }
//             break;
//         case direction_west:
//             if (m_to_direct == m_fr_direct ||
//                     _fr_Y >= m_to_pos_west ||
//                     m_to_pos_west <= m_fr_pos_west) {
//                 return 0;
//             }
//             vir_to_X = prop_X[ind_prop_to] = _fr_X;
//             vir_to_Y = prop_Y[ind_prop_to] = 2 * m_to_pos_west - _fr_Y;
//             vir_to_Z = prop_Z[ind_prop_to] = _fr_Z;
//             from_p_X = _fr_X;
//             from_p_Y = _fr_Y;
//             from_p_Z = _fr_Z;
//             to_p_X = m_to_pos_south;
//             to_p_Y = m_to_pos_west;
//             to_p_Z = Z_RX;
//             for (to_p_X = m_to_pos_south;
//                     to_p_X >= m_to_pos_north;
//                     to_p_X--) {
//                 interSecTag = detectIntersection(from_p_X, from_p_Y, from_p_Z,
//                                                  to_p_X, to_p_Y, to_p_Z,
//                                                  inter_p_X, inter_p_Y, inter_p_Z,
//                                                  ind_mirror_fr);
//                 if (interSecTag)
//                     freespaceTag = LOS_building_double(inter_p_X, inter_p_Y, inter_p_Z, ind_mirror_fr,
//                                                        to_p_X, to_p_Y, to_p_Z, ind_mirror_to);
//                 if (interSecTag && freespaceTag)
//                     break;
//             }
//             if (to_p_X >= m_to_pos_north) {
//                 int pre_X = (int)to_p_X;
//                 to_p_X++;
//                 if (to_p_X > m_to_pos_south)
//                     to_p_X = m_to_pos_south;
//                 prop_angle_range[ind_prop_to][angle_ind_min] =
//                     atan((vir_to_X - to_p_X) /
//                          (vir_to_Y - m_to_pos_west));
//                 for (to_p_X = m_to_pos_north;
//                         to_p_X < pre_X;
//                         to_p_X++) {
//                     interSecTag = detectIntersection(from_p_X, from_p_Y, from_p_Z,
//                                                      to_p_X, to_p_Y, to_p_Z,
//                                                      inter_p_X, inter_p_Y, inter_p_Z,
//                                                      ind_mirror_fr);
//                     if (interSecTag)
//                         freespaceTag = LOS_building_double(inter_p_X, inter_p_Y, inter_p_Z, ind_mirror_fr,
//                                                            to_p_X, to_p_Y, to_p_Z, ind_mirror_to);
//                     if (interSecTag && freespaceTag)
//                         break;
//                 }
//                 to_p_X--;
//                 if (to_p_X < m_to_pos_north)
//                     to_p_X = m_to_pos_north;
//                 prop_angle_range[ind_prop_to][angle_ind_max] =
//                     atan((vir_to_X - to_p_X) /
//                          (vir_to_Y - m_to_pos_west));
//                 return 1;
//             } else {
//                 return 0;
//             }
//             break;
//         default:
//             printf("%s(line %d): MIRROR DIRECTION ERROR, exiting...\n", __FILE__, __LINE__);
//             exit(100);
//             break;
//         }
//     }
// }
static int getAngleRange1(double _fr_X, double _fr_Y, double _fr_Z,
	int ind_prop_fr, int ind_mirror_fr,
	int ind_prop_to, int ind_mirror_to,
	int X_TX, int Y_TX, double Z_TX,
	int X_RX, int Y_RX, double Z_RX)
{
	int boundary_X_min;
	int boundary_X_max;
	int boundary_Y_min;
	int boundary_Y_max;
	if (X_TX < X_RX) {
		boundary_X_min = X_TX;
		boundary_X_max = X_RX;
	}
	else {
		boundary_X_min = X_RX;
		boundary_X_max = X_TX;
	}
	if (Y_TX < Y_RX) {
		boundary_Y_min = Y_TX;
		boundary_Y_max = Y_RX;
	}
	else {
		boundary_Y_min = Y_RX;
		boundary_Y_max = Y_TX;
	}
	//¸÷¸öµã
	double from_p_X, from_p_Y, from_p_Z;
	double to_p_X, to_p_Y, to_p_Z;
	//double inter_p_X, inter_p_Y, inter_p_Z;
	double vir_to_X, vir_to_Y, vir_to_Z;
	//¸÷¸ö±êÇ©
	//int freespaceTag;
	//int interSecTag;
	if (ind_prop_fr < 0 || ind_mirror_fr < 0) {
		int m_to_direct = mirror_direction[ind_mirror_to];
		double m_to_pos_north = mirror_pos_north[ind_mirror_to];
		double m_to_pos_east = mirror_pos_east[ind_mirror_to];
		double m_to_pos_south = mirror_pos_south[ind_mirror_to];
		double m_to_pos_west = mirror_pos_west[ind_mirror_to];
		if ((m_to_pos_south < boundary_X_min || m_to_pos_north > boundary_X_max) &&
			(m_to_pos_west > boundary_Y_max || m_to_pos_east < boundary_Y_min)) {
			return 0;
		}
		switch (m_to_direct) {
		case direction_north:
			if (_fr_X >= m_to_pos_north) {
				return 0;
			}
			vir_to_X = prop_X[ind_prop_to] = 2 * m_to_pos_north - _fr_X;
			vir_to_Y = prop_Y[ind_prop_to] = _fr_Y;
			vir_to_Z = prop_Z[ind_prop_to] = _fr_Z;
			from_p_X = _fr_X;
			from_p_Y = _fr_Y;
			from_p_Z = _fr_Z;
			to_p_X = m_to_pos_north;
			to_p_Y = m_to_pos_west;
			to_p_Z = Z_TX;
			for (to_p_Y = m_to_pos_west;
				to_p_Y <= m_to_pos_east;
				to_p_Y++) {
				if (LOS_building_double(from_p_X, from_p_Y, from_p_Z, ind_mirror_fr,
					to_p_X, to_p_Y, to_p_Z, ind_mirror_to))
					break;
			}
			if (to_p_Y <= m_to_pos_east) {
				int pre_Y = (int)to_p_Y;
				to_p_Y--;
				if (to_p_Y < m_to_pos_west)
					to_p_Y = m_to_pos_west;
				prop_angle_range[ind_prop_to][angle_ind_min] =
					atan((to_p_Y - vir_to_Y) /
						(vir_to_X - m_to_pos_north));
				for (to_p_Y = m_to_pos_east;
					to_p_Y > pre_Y;
					to_p_Y--) {
					if (LOS_building_double(from_p_X, from_p_Y, from_p_Z, ind_mirror_fr,
						to_p_X, to_p_Y, to_p_Z, ind_mirror_to))
						break;
				}
				to_p_Y++;
				if (to_p_Y > m_to_pos_east)
					to_p_Y = m_to_pos_east;
				prop_angle_range[ind_prop_to][angle_ind_max] =
					atan((to_p_Y - vir_to_Y) /
						(vir_to_X - m_to_pos_north));
				return 1;
			}
			else {
				return 0;
			}
			break;
		case direction_east:
			if (_fr_Y <= m_to_pos_east) {
				return 0;
			}
			vir_to_X = prop_X[ind_prop_to] = _fr_X;
			vir_to_Y = prop_Y[ind_prop_to] = 2 * m_to_pos_east - _fr_Y;
			vir_to_Z = prop_Z[ind_prop_to] = _fr_Z;
			from_p_X = _fr_X;
			from_p_Y = _fr_Y;
			from_p_Z = _fr_Z;
			to_p_X = m_to_pos_north;
			to_p_Y = m_to_pos_east;
			to_p_Z = Z_TX;
			for (to_p_X = m_to_pos_north;
				to_p_X <= m_to_pos_south;
				to_p_X++) {
				if (LOS_building_double(from_p_X, from_p_Y, from_p_Z, ind_mirror_fr,
					to_p_X, to_p_Y, to_p_Z, ind_mirror_to))
					break;
			}
			if (to_p_X <= m_to_pos_south) {
				int pre_X = (int)to_p_X;
				to_p_X--;
				if (to_p_X < m_to_pos_north)
					to_p_X = m_to_pos_north;
				prop_angle_range[ind_prop_to][angle_ind_min] =
					atan((to_p_X - vir_to_X) /
						(m_to_pos_east - vir_to_Y));
				for (to_p_X = m_to_pos_south;
					to_p_X > pre_X;
					to_p_X--) {
					if (LOS_building_double(from_p_X, from_p_Y, from_p_Z, ind_mirror_fr,
						to_p_X, to_p_Y, to_p_Z, ind_mirror_to))
						break;
				}
				to_p_X++;
				if (to_p_X > m_to_pos_south)
					to_p_X = m_to_pos_south;
				prop_angle_range[ind_prop_to][angle_ind_max] =
					atan((to_p_X - vir_to_X) /
						(m_to_pos_east - vir_to_Y));
				return 1;
			}
			else {
				return 0;
			}
			break;
		case direction_south:
			if (_fr_X <= m_to_pos_south) {
				return 0;
			}
			vir_to_X = prop_X[ind_prop_to] = 2 * m_to_pos_south - _fr_X;
			vir_to_Y = prop_Y[ind_prop_to] = _fr_Y;
			vir_to_Z = prop_Z[ind_prop_to] = _fr_Z;
			from_p_X = _fr_X;
			from_p_Y = _fr_Y;
			from_p_Z = _fr_Z;
			to_p_X = m_to_pos_south;
			to_p_Y = m_to_pos_east;
			to_p_Z = Z_TX;
			for (to_p_Y = m_to_pos_east;
				to_p_Y >= m_to_pos_west;
				to_p_Y--) {
				if (LOS_building_double(from_p_X, from_p_Y, from_p_Z, ind_mirror_fr,
					to_p_X, to_p_Y, to_p_Z, ind_mirror_to))
					break;
			}
			if (to_p_Y >= m_to_pos_west) {
				int pre_Y = (int)to_p_Y;
				to_p_Y++;
				if (to_p_Y > m_to_pos_east)
					to_p_Y = m_to_pos_east;
				prop_angle_range[ind_prop_to][angle_ind_min] =
					atan((vir_to_Y - to_p_Y) /
						(m_to_pos_south - vir_to_X));
				for (to_p_Y = m_to_pos_west;
					to_p_Y < pre_Y;
					to_p_Y++) {
					if (LOS_building_double(from_p_X, from_p_Y, from_p_Z, ind_mirror_fr,
						to_p_X, to_p_Y, to_p_Z, ind_mirror_to))
						break;
				}
				to_p_Y--;
				if (to_p_Y < m_to_pos_west)
					to_p_Y = m_to_pos_west;
				prop_angle_range[ind_prop_to][angle_ind_max] =
					atan((vir_to_Y - to_p_Y) /
						(m_to_pos_south - vir_to_X));
				return 1;
			}
			else {
				return 0;
			}
			break;
		case direction_west:
			if (_fr_Y >= m_to_pos_west) {
				return 0;
			}
			vir_to_X = prop_X[ind_prop_to] = _fr_X;
			vir_to_Y = prop_Y[ind_prop_to] = 2 * m_to_pos_west - _fr_Y;
			vir_to_Z = prop_Z[ind_prop_to] = _fr_Z;
			from_p_X = _fr_X;
			from_p_Y = _fr_Y;
			from_p_Z = _fr_Z;
			to_p_X = m_to_pos_south;
			to_p_Y = m_to_pos_west;
			to_p_Z = Z_TX;
			for (to_p_X = m_to_pos_south;
				to_p_X >= m_to_pos_north;
				to_p_X--) {
				if (LOS_building_double(from_p_X, from_p_Y, from_p_Z, ind_mirror_fr,
					to_p_X, to_p_Y, to_p_Z, ind_mirror_to))
					break;
			}
			if (to_p_X >= m_to_pos_north) {
				int pre_X = (int)to_p_X;
				to_p_X++;
				if (to_p_X > m_to_pos_south)
					to_p_X = m_to_pos_south;
				prop_angle_range[ind_prop_to][angle_ind_min] =
					atan((vir_to_X - to_p_X) /
						(vir_to_Y - m_to_pos_west));
				for (to_p_X = m_to_pos_north;
					to_p_X < pre_X;
					to_p_X++) {
					if (LOS_building_double(from_p_X, from_p_Y, from_p_Z, ind_mirror_fr,
						to_p_X, to_p_Y, to_p_Z, ind_mirror_to))
						break;
				}
				to_p_X--;
				if (to_p_X < m_to_pos_north)
					to_p_X = m_to_pos_north;
				prop_angle_range[ind_prop_to][angle_ind_max] =
					atan((vir_to_X - to_p_X) /
						(vir_to_Y - m_to_pos_west));
				return 1;
			}
			else {
				return 0;
			}
			break;
		default:
			printf("%s(line %d): MIRROR DIRECTION ERROR, exiting...\n", __FILE__, __LINE__);
			exit(100);
			break;
		}
	}
	else {
		int m_fr_direct = mirror_direction[ind_mirror_fr];
		double m_fr_pos_north = mirror_pos_north[ind_mirror_fr];
		double m_fr_pos_east = mirror_pos_east[ind_mirror_fr];
		double m_fr_pos_south = mirror_pos_south[ind_mirror_fr];
		double m_fr_pos_west = mirror_pos_west[ind_mirror_fr];
		int m_to_direct = mirror_direction[ind_mirror_to];
		double m_to_pos_north = mirror_pos_north[ind_mirror_to];
		double m_to_pos_east = mirror_pos_east[ind_mirror_to];
		double m_to_pos_south = mirror_pos_south[ind_mirror_to];
		double m_to_pos_west = mirror_pos_west[ind_mirror_to];
		if ((m_to_pos_south < boundary_X_min || m_to_pos_north > boundary_X_max) &&
			(m_to_pos_west > boundary_Y_max || m_to_pos_east < boundary_Y_min)) {
			return 0;
		}
		//printf("%s(line %d): getAngleRange ERROR, exiting...\n", __FILE__, __LINE__);
		//exit(101);
		double tmp_angle_min1;
		double tmp_angle_max1;
		double tmp_angle_min2;
		double tmp_angle_max2;
		int direct_diff =
			(m_fr_direct - m_to_direct + 4) % 4;
		switch (direct_diff) {
		case 0:
			return 0;
			break;
		case 1:
			tmp_angle_min1 = pi / 2.0
				- prop_angle_range[ind_prop_fr][angle_ind_max];
			tmp_angle_max1 = pi / 2.0
				- prop_angle_range[ind_prop_fr][angle_ind_min];
			break;
		case 2:
			tmp_angle_min1 = 0.0
				- prop_angle_range[ind_prop_fr][angle_ind_max];
			tmp_angle_max1 = 0.0
				- prop_angle_range[ind_prop_fr][angle_ind_min];
			break;
		case 3:
			tmp_angle_min1 = -pi / 2.0
				- prop_angle_range[ind_prop_fr][angle_ind_max];
			tmp_angle_max1 = -pi / 2.0
				- prop_angle_range[ind_prop_fr][angle_ind_min];
			break;
		default:
			printf("%s(line %d): MIRROR DIRECTION ERROR, exiting...\n", __FILE__, __LINE__);
			exit(100);
			break;
		}
		switch (m_to_direct) {
		case direction_north:
			if (m_to_direct == m_fr_direct ||
				_fr_X >= m_to_pos_north ||
				m_to_pos_north <= m_fr_pos_north) {
				return 0;
			}
			vir_to_X = prop_X[ind_prop_to] = 2 * m_to_pos_north - _fr_X;
			vir_to_Y = prop_Y[ind_prop_to] = _fr_Y;
			vir_to_Z = prop_Z[ind_prop_to] = _fr_Z;
			tmp_angle_min2 =
				atan((m_to_pos_west - vir_to_Y) /
					(vir_to_X - m_to_pos_north));
			tmp_angle_max2 =
				atan((m_to_pos_east - vir_to_Y) /
					(vir_to_X - m_to_pos_north));
			if (tmp_angle_min1 > tmp_angle_min2)
				prop_angle_range[ind_prop_to][angle_ind_min] =
				tmp_angle_min1;
			else
				prop_angle_range[ind_prop_to][angle_ind_min] =
				tmp_angle_min2;
			if (tmp_angle_max1 < tmp_angle_max2)
				prop_angle_range[ind_prop_to][angle_ind_max] =
				tmp_angle_max1;
			else
				prop_angle_range[ind_prop_to][angle_ind_max] =
				tmp_angle_max2;
			if (prop_angle_range[ind_prop_to][angle_ind_min] <=
				prop_angle_range[ind_prop_to][angle_ind_max])
				return 1;
			else
				return 0;
			break;
		case direction_east:
			if (m_to_direct == m_fr_direct ||
				_fr_Y <= m_to_pos_east ||
				m_to_pos_east >= m_fr_pos_east) {
				return 0;
			}
			vir_to_X = prop_X[ind_prop_to] = _fr_X;
			vir_to_Y = prop_Y[ind_prop_to] = 2 * m_to_pos_east - _fr_Y;
			vir_to_Z = prop_Z[ind_prop_to] = _fr_Z;
			tmp_angle_min2 =
				atan((m_to_pos_north - vir_to_X) /
					(m_to_pos_east - vir_to_Y));
			tmp_angle_max2 =
				atan((m_to_pos_south - vir_to_X) /
					(m_to_pos_east - vir_to_Y));
			if (tmp_angle_min1 > tmp_angle_min2)
				prop_angle_range[ind_prop_to][angle_ind_min] =
				tmp_angle_min1;
			else
				prop_angle_range[ind_prop_to][angle_ind_min] =
				tmp_angle_min2;
			if (tmp_angle_max1 < tmp_angle_max2)
				prop_angle_range[ind_prop_to][angle_ind_max] =
				tmp_angle_max1;
			else
				prop_angle_range[ind_prop_to][angle_ind_max] =
				tmp_angle_max2;
			if (prop_angle_range[ind_prop_to][angle_ind_min] <=
				prop_angle_range[ind_prop_to][angle_ind_max])
				return 1;
			else
				return 0;
			break;
		case direction_south:
			if (m_to_direct == m_fr_direct ||
				_fr_X <= m_to_pos_south ||
				m_to_pos_south >= m_fr_pos_south) {
				return 0;
			}
			vir_to_X = prop_X[ind_prop_to] = 2 * m_to_pos_south - _fr_X;
			vir_to_Y = prop_Y[ind_prop_to] = _fr_Y;
			vir_to_Z = prop_Z[ind_prop_to] = _fr_Z;
			tmp_angle_min2 =
				atan((vir_to_Y - m_to_pos_east) /
					(m_to_pos_south - vir_to_X));
			tmp_angle_max2 =
				atan((vir_to_Y - m_to_pos_west) /
					(m_to_pos_south - vir_to_X));
			if (tmp_angle_min1 > tmp_angle_min2)
				prop_angle_range[ind_prop_to][angle_ind_min] =
				tmp_angle_min1;
			else
				prop_angle_range[ind_prop_to][angle_ind_min] =
				tmp_angle_min2;
			if (tmp_angle_max1 < tmp_angle_max2)
				prop_angle_range[ind_prop_to][angle_ind_max] =
				tmp_angle_max1;
			else
				prop_angle_range[ind_prop_to][angle_ind_max] =
				tmp_angle_max2;
			if (prop_angle_range[ind_prop_to][angle_ind_min] <=
				prop_angle_range[ind_prop_to][angle_ind_max])
				return 1;
			else
				return 0;
			break;
		case direction_west:
			if (m_to_direct == m_fr_direct ||
				_fr_Y >= m_to_pos_west ||
				m_to_pos_west <= m_fr_pos_west) {
				return 0;
			}
			vir_to_X = prop_X[ind_prop_to] = _fr_X;
			vir_to_Y = prop_Y[ind_prop_to] = 2 * m_to_pos_west - _fr_Y;
			vir_to_Z = prop_Z[ind_prop_to] = _fr_Z;
			tmp_angle_min2 =
				atan((vir_to_X - m_to_pos_south) /
					(vir_to_Y - m_to_pos_west));
			tmp_angle_max2 =
				atan((vir_to_X - m_to_pos_north) /
					(vir_to_Y - m_to_pos_west));
			if (tmp_angle_min1 > tmp_angle_min2)
				prop_angle_range[ind_prop_to][angle_ind_min] =
				tmp_angle_min1;
			else
				prop_angle_range[ind_prop_to][angle_ind_min] =
				tmp_angle_min2;
			if (tmp_angle_max1 < tmp_angle_max2)
				prop_angle_range[ind_prop_to][angle_ind_max] =
				tmp_angle_max1;
			else
				prop_angle_range[ind_prop_to][angle_ind_max] =
				tmp_angle_max2;
			if (prop_angle_range[ind_prop_to][angle_ind_min] <=
				prop_angle_range[ind_prop_to][angle_ind_max])
				return 1;
			else
				return 0;
			break;
		default:
			printf("%s(line %d): MIRROR DIRECTION ERROR, exiting...\n", __FILE__, __LINE__);
			exit(100);
			break;
		}
	}
}
static int detectIntersection(double fr_X, double fr_Y, double fr_Z,
	double to_X, double to_Y, double to_Z,
	double& sect_X, double& sect_Y, double& sect_Z,
	int ind_mirror)
{
	double h = fr_Z;
	double cc = to_Z;
	double a = fr_X;
	double b = fr_Y;
	double i = to_X;
	double j = to_Y;
	double z;  //z?????¡À??¨¦?¦Ì????¨¨   x?¡éy?a¨¢?¦Ì?o¨¢¡ÁY¡Á?¡À¨º2?¡ê¡§?y??¨ºy¡ê? x1?a¦Ì£¤??2?¨¢?¡ê¡§¡ä?¡¤?o?¡ê? z1?¡éz2¦Ì?D?¦Ì?¡Á?¡À¨º¦Ì????¨¨
	double k, k1;          //¨¢?¦Ì?3¨¦??¦Ì?D¡À?¨º
	double x2;            //¨®?¨®¨²¡ä?¡ä¡é?¨´?¨®¦Ì?¡Á?¡À¨º
	double y2;
	int targetDirect = mirror_direction[ind_mirror];
	//
	switch (targetDirect) {
	case direction_north:
		if (a - i == 0) return 0; //Æ½ÐÐ
		k = (b - j) / (a - i);
		k1 = (cc - h) / (a - i);
		x2 = mirror_pos_north[ind_mirror];
		y2 = k * (x2 - i) + j;
		z = k1 * (x2 - i) + h;
		sect_X = (double)x2;
		sect_Y = (double)y2;
		sect_Z = z;
		if ((sect_X - fr_X) * (sect_X - to_X) > 0)  //Î´ÔÚTxºÍRxÖ®¼ä
			return 0;
		if (y2 < mirror_pos_west[ind_mirror] ||
			y2 > mirror_pos_east[ind_mirror]) {//
			return 0;
		}
		else {
			//if ((sect_X - fr_X)*(sect_X - to_X) == 0)//Î´ÔÚTxºÍRxÖ®¼ä
			//  int check = 1;
			return 1;
		}
		break;
	case direction_east:
		if (b - j == 0) return 0;
		k = (a - i) / (b - j);
		k1 = (cc - h) / (b - j);
		y2 = mirror_pos_east[ind_mirror];
		x2 = k * (y2 - j) + i;
		z = k1 * (y2 - j) + h;
		sect_X = (double)x2;
		sect_Y = (double)y2;
		sect_Z = z;
		if ((sect_Y - fr_Y) * (sect_Y - to_Y) > 0)  //Î´ÔÚTxºÍRxÖ®¼ä
			return 0;
		if (x2 < mirror_pos_north[ind_mirror] ||
			x2 > mirror_pos_south[ind_mirror]) {//
			return 0;
		}
		else {
			//if ((sect_Y - fr_Y)*(sect_Y - to_Y) == 0)//Î´ÔÚTxºÍRxÖ®¼ä
			//  int check = 1;
			return 1;
		}
		break;
	case direction_south:
		if (a - i == 0) return 0; //Æ½ÐÐ
		k = (b - j) / (a - i);
		k1 = (cc - h) / (a - i);
		x2 = mirror_pos_south[ind_mirror];
		y2 = k * (x2 - i) + j;
		z = k1 * (x2 - i) + h;
		sect_X = (double)x2;
		sect_Y = (double)y2;
		sect_Z = z;
		if ((sect_X - fr_X) * (sect_X - to_X) > 0)  //Î´ÔÚTxºÍRxÖ®¼ä
			return 0;
		if (y2 < mirror_pos_west[ind_mirror] ||
			y2 > mirror_pos_east[ind_mirror]) {//
			return 0;
		}
		else {
			//if ((sect_X - fr_X)*(sect_X - to_X) == 0)//Î´ÔÚTxºÍRxÖ®¼ä
			//  int check = 1;
			return 1;
		}
		break;
	case direction_west:
		if (b - j == 0) return 0;
		k = (a - i) / (b - j);
		k1 = (cc - h) / (b - j);
		y2 = mirror_pos_west[ind_mirror];
		x2 = k * (y2 - j) + i;
		z = k1 * (y2 - j) + h;
		sect_X = (double)x2;
		sect_Y = (double)y2;
		sect_Z = z;
		if ((sect_Y - fr_Y) * (sect_Y - to_Y) > 0)  //Î´ÔÚTxºÍRxÖ®¼ä
			return 0;
		if (x2 < mirror_pos_north[ind_mirror] ||
			x2 > mirror_pos_south[ind_mirror]) {//
			return 0;
		}
		else {
			//if ((sect_Y - fr_Y)*(sect_Y - to_Y) == 0)//Î´ÔÚTxºÍRxÖ®¼ä
			//  int check = 1;
			return 1;
		}
		break;
	default:
		printf("%s(line %d): MIRROR DIRECTION ERROR, exiting...\n", __FILE__, __LINE__);
		exit(100);
		break;
	}
	return 0;
}
static double Lifetime()
{
	// initialization
	for (int i = 0; i < n_relay_URBAN; i++) {
		n_data_local_RELAY[i] = 0;
		n_data_hop_RELAY[i] = 0;
		n_data_fwd_RELAY[i] = 0;
		energy_consumed_RELAY[i] = 0;
		LT_RELAY[i] = 0;
	}
	// sensor nodes
	for (int i = 0; i < n_sensor_URBAN; i++) {
		double minD = INF_DOUBLE_HDSN_URBAN;
		double tmpD;
		int ID = -1;
		for (int j = 0; j < n_relay_URBAN; j++) {
			tmpD = allPathLoss_s_r[i][j];
			if (tmpD < minD && connectstatus_sensor_relay[i][j]) {
				minD = tmpD;
				ID = j;
			}
		}
		if (ID == -1) {
			hopID_SENSOR[i] = n_relay_URBAN;
			com_pathloss_SENSOR[i] = INF_DOUBLE_HDSN_URBAN;
		}
		else {
			hopID_SENSOR[i] = ID;
			com_pathloss_SENSOR[i] = minD;
			n_data_local_RELAY[ID] ++;
		}
	}
	/*std_dist_SENSOR = 0.0;
	for (int i = 0; i < N_SENSOR; i++) {
	std_dist_SENSOR += (com_dist_SENSOR[i] - avg_dist_SENSOR) * (com_dist_SENSOR[i] - avg_dist_SENSOR);
	}
	std_dist_SENSOR = sqrt(std_dist_SENSOR / N_SENSOR);*/
	// relay nodes
	//double pathloss2sink[n_relay_URBAN];
	//int    ID_RELAY[n_relay_URBAN];
	for (int i = 0; i < n_relay_URBAN; i++) {
		ID_RELAY_HDSN_URBAN[i] = i;
		if (avaiStatus_relay[i])
			pathloss2sink[i] = PropaPathLoss((int)pos3D_RELAY[i][X], (int)pos3D_RELAY[i][Y], pos3D_RELAY[i][Z],
				(int)SINK_X, (int)SINK_Y, SINK_Z);
		else
			pathloss2sink[i] = INF_DOUBLE_HDSN_URBAN;
	}
	for (int i = n_relay_URBAN - 1; i > 0; i--) {
		for (int j = 0; j < i; j++) {
			if (pathloss2sink[j] < pathloss2sink[j + 1]) {
				double tmpD = pathloss2sink[j + 1];
				pathloss2sink[j + 1] = pathloss2sink[j];
				pathloss2sink[j] = tmpD;
				int tmpID = ID_RELAY_HDSN_URBAN[j + 1];
				ID_RELAY_HDSN_URBAN[j + 1] = ID_RELAY_HDSN_URBAN[j];
				ID_RELAY_HDSN_URBAN[j] = tmpID;
			}
		}
	}
	for (int i = 0; i < n_relay_URBAN; i++) {
		int ID = ID_RELAY_HDSN_URBAN[i];
		if (pathloss2sink[i] == INF_DOUBLE_HDSN_URBAN) {
			n_data_fwd_RELAY[ID] = 0;
			n_data_local_RELAY[ID] = 0;
			n_data_hop_RELAY[ID] = 0;
			com_pathloss_RELAY[ID] = 0.0;
			continue;
		}
		n_data_fwd_RELAY[ID] = n_data_local_RELAY[ID] + n_data_hop_RELAY[ID];
		double minD = pathloss2sink[i];
		int tmpID = -1;
		for (int j = i + 1; j < n_relay_URBAN; j++) {
			int id = ID_RELAY_HDSN_URBAN[j];
			double tmpD = allPathLoss_r_r[ID][id];
			if (tmpD < minD) {
				minD = tmpD;
				tmpID = id;
			}
		}
		if (tmpID == -1) {
			hopID_RELAY[ID] = n_relay_URBAN;
			com_pathloss_RELAY[ID] = minD;
		}
		else {
			hopID_RELAY[ID] = tmpID;
			n_data_hop_RELAY[tmpID] += n_data_fwd_RELAY[ID];
			com_pathloss_RELAY[ID] = minD;
		}
	}
	double energy_max = -1.0;
	for (int i = 0; i < n_relay_URBAN; i++) {
		energy_consumed_RELAY[i] = n_data_fwd_RELAY[i] * com_pathloss_RELAY[i];
		if (energy_consumed_RELAY[i] > energy_max) {
			energy_max = energy_consumed_RELAY[i];
		}
	}
	return (energy_max / (n_sensor_URBAN * th_PL_relay));
}